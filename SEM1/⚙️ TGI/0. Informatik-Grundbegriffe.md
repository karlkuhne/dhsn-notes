e0046027@ba-sachsen.de
## 0.1 Informatik Grundbegriffe

- Wissenschaft der systemischen Verarbeitung von Daten (automatische Verarbeitung mit Digitalrechnern)
- Strukturwissenschaft: behandelt und untersucht von Menschen geschaffene formale Strukturen (Daten-, Sprach-, System-)
  Disziplin der Informationswissenschaften
- Formulierung und Realisierung von Algorithmen

### 0.1.1 Teilgebiete

__Theoretische Informatik__
Formale Sprachen, Automatentheorie, Theorie der Berechenbarkeit, Komplexitätstheorie, Algorithmen-Analyse, Theorie der Programmierung

__Technische Informatik__
Hardwarekomponenten, Schaltnetzwerke, Schnittstellentechnik, Computerkonstruktion, Steuerungen, Mikroprogrammierung

__Praktische Informatik__
Algorithmen und Datenstrukturen, Softwaretechnik, Programmiersprachen und Compiler, Programmiermethoden, Betriebssysteme

__Angewandte Informatik__
Informationssysteme, Prozess-Steuerung, Künstliche Intelligenz, Computergrafik, Simulation und Modellierung, spezifische Gebiete in Natur- und Ingenieurwissenschaften (Medieninformatik, Bioinformatik, ...)

## 0.2 Daten und Informationen

- Daten (Angaben über reale Objekte, Eigenschaften von realen Objekten, Darstellung mit Symbolen und Zeichenketten)
- Informationen (abstrakt, zweckbezogener Inhalt von Daten)
- Nachrichten (Informationsträger)

### 0.2.1 Speicherung von Daten

- Zahlen, Texte, physikalische Größen etc. als Binärcode
- kann vom Computer verarbeitet werden
- physikalische Größen werden diskretisiert (Daten werden in festes Schema (bspw. beim Thermometer Rundung auf Zehntel)) und digitalisiert
- Bsp: Temparaturgraph wird diskretisiert zu stündlichen Werten

## 0.3 Binärsystem

- Genauigkeit (beliebig genau angebbar)
- geringe Störanfälligkeit
- Binärsymbole können relativ durch physikalische Größen dargestellt werden
- verlustlos speicherbar
- Bsp. Loch vs kein Loch bei Lochkarten

- Bit kleinstmögliche Speichereinheit, 0 oder 1
- eine Folge von acht Bit ist ein Byte (halbes Byte ist ein _Nibble_)
- Byte ist Maßeinheit für Speicherkapazität
- SI-Präfixe, Binärpräfixe, eine Einheit = 10^3 = 1000 statt 1024 (Abweichung)

- Stellenwertsystem (Position legt Wert fest)
- von höchster zu niedrigster Stelle
- 2 hoch der Index, beginnend rechts bei hoch 0
- Bsp: $0101 \equiv 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 \equiv 5$

### 0.3.1 Negative Zahlen in Binär

  1. Einerkomplement der posiven Zahl bilden: jede Zahl umdrehen
  2. 1 addieren
- damit lässt sich Subtraktion als Addition ausführen
- Beispiel: 10 + (-10)
  00001010
  +11110110
  = 00000000
- In einem Byte:
  ohne Vorzeichen: bis 255 schreiben (10000000)
  mit Vorzeichen: (-128 bis 127) (10000000 bis 01111111)
- Allgemeine Summenformel fürs Binärsystem (siehe Folie)

Bsp.:

108 entspricht in Binär: 0110 1100
Um das zu negieren dreht man die Zahl um und addiert 1:
-108 entspricht: 1001 0011 + 1 = 1001 0111

- 32-Bit [[2. Gleitkommazahlen]]
- es gibt ein Vorzeichenbit, einen Teil Exponent und einen Teil Mantisse

__Hexadezimalsystem__

$1234_{16} \equiv 1 \cdot 16^3 + 2 \cdot 16^2 + 3 \cdot 16^1 + 4 \cdot 16^0$

## 0.4 Darstellung von Texten

- werden codiert
- ASCII, ANSI (gleich aber andere Sonderzeichen), Unicode, EBCDIC
- MS-DOS und UNIX verwenden ACII, Windows ab Win3.x ANSI
- A: 0x41 , 65, ´0101 - 01000001
  a: 0x61, 97, ´141 - ...
  unterscheiden sich in einem Bit

## 0.5 Hardware und Software

- Firmware zählt meist zur Hardware
- Software teilt sich in System- / Basissoftware und Anwender-Software
- Von Neumann Computer
- Betriebssystem: Schnittstelle Mensch Computer
  (Ein- und Ausgabe, Prozesseverwaltung, Dateisystem, Schutzmechanismen, Datum und Zeit, Hauptspeicherverwaltung, Netzwerkdienste)

- Dateisysteme meist hierarchisch aufgebaut: Wurzel
- in der Systemumgung können Systemvariablen angelegt werden
  dadurch unabhängig von der konkreten Umgebung
- in Programmen nie absolute Pfade angeben

## 0.6 Algorithmus

- Muss von einer Maschine ausführbar sein, die den Inhalt nicht versteht
- Notation in Form einer Syntax (formale Regeln) und Semantik (Bedeutung der Konstrukte)
- Programm: Ein in einer Programmiersprache formulierter Algorithmus
- Programmieren: Alles von Problemstellung bis zum fertigen Programm

### 0.6.1 Theorem Böhm und Jacobini

- Gibt es zur Lösung eines Problems einen Algorithmus, lässt sich dieser unter alleiniger Verwendung der drei Grundstrukturen Sequenz (Folge), Selektion (Verzweigung) und Zyklus (Iteration, Schleife) darstellen
- Grundlage für "strukturierte Programmierung" (ohne GOTO)

### 0.6.2 Generationen von Programmiersprachen

#### 0.6.2.1 Erste Generation: Maschinensprachen

- Befehle und Adressen in Binärform
- Nur auf dem jeweiligen Prozessortyp lauffähig
- am Anfang der einzige Weg

#### 0.6.2.2 Zweite Generation: Assemblersprachen

- Für Machinen-Befehle werden "Mnemoniks" (Namen, Bezeichnungen) eingeführt und Adressen bekommen symbolische Namen
- Nur auf dem jeweiligen Prozessor lauffähig
- Für einen Prozessortyp mehrere Assemblersprachen
- Übersetzer heißen Assember

#### 0.6.2.3 Dritte Generation: Problemorientierte Sprachen

- ab dieser Generation beginnen die "höheren Programmiersprachen"
- "prozedurale Sprachen" (Beschreibung der Algorithmen und Abläufe)
- Folge, Verzweigung, Sequenz
- Möglichkeiten für strukturierte Programmierung
- sehr viele Sprachen oft auf bestimmte Anwendungsgebiete zugeschnitten
- Quellprogramm-Dateien werden durch Compiler in Zwischencode-Dateien (Objekt-Dateien) oder direkt in Maschinencode übersetzt
- Objekt-Dateien werden durch Linker in Machinencode übertragen

#### 0.6.2.4 Vierte Generation: Deklarative Sprachen

- Beschreiben, was das Programm leisten soll (nichtprozedual)
- kein Einfluss auf interne Abläufe oder Umsetzung
- Meist auf bestimmte Aufgabengebiete zugeschnitten (Datenbanken, ...)
- Bsp: SQL

#### 0.6.2.5 Fünfte Generation: AI

- Fokus auf Künstliche Intelligenz, Expertensysteme und natürliche Sprachverarbeitung
- Ziel ist es, Computerprobleme auf eine menschenähnlichere Weise zu lösen

### 0.6.3 Aufwandspyramide

- Machinensprachen
- Assemblersprachen
- Höhere Programmiersprachen
- Grafiksprachen
- Spezifikationssprachen
- Pseudosprachen
- natürliche Sprachen

### 0.6.4 Darstellungsformen

#### 0.6.4.1 Natürliche Sprachen

- verbale Beschreibung der einzelnen Schritte
- oft schwer verständlich
- Beschreibung muss sehr genau sein (lang, unübersichtlich)

#### 0.6.4.2 PAP (DIN 66 001)

- grafische Darstellung
- genormte Symbolik

#### 0.6.4.3 Struktogramm

- Anweisungen hintereinander
- Verzweigung (ohne oder mit Alternative)
- Mehrfachverzeigung (ohne oder mit default-Zweig)
- Schleifen (kopfgesteuert, fußgesteuert (mindestens ein Durchlauf), Zählschleife)

#### 0.6.4.4 Pseudo-Sprachen

- Schlüsselwörter sehr stark an existierende Angelehnt
- oft in Lehrbüchern

## 0.7 Programmiersprachen

### 0.7.1 Vorbetrachtungen

- theoretisch könnte alles in einer Sprache gemacht werden
- für verschiedene Aufgabenstellungen wurden verschiedene darauf angepasste Programmiersprachen entwickelt (problemorientiert)
- durch immer komplexer werdende Programme wurden neue Betrachtungweisen und entsprechende Programmiersprachen entwickelt um diese beherrschbar zu machen

### 0.7.2 Klassifizierung

#### 0.7.2.1 Imperative Programmierparadigmen

- Paradigmen beschreiben, **wie** ein Problem Schritt für Schritt gelöst wird
- fokussieren sich auf Anweisungen, die den Zustand des Programms ändern

__Prozedurale Programmierung__

* organisiert Code in Prozeduren, Funktionen oder Subroutinen
* Fokus auf die sequentielle Ausführung von Anweisungen
* trennt Daten und Funktionen oft
* Beispiele: Pascal, C, Fortran

#### 0.7.2.2 Deklarative Programmierparadigmen

- Paradigmen beschreiben, **was** das Problem ist oder **was** erreicht werden soll, ohne explizit den Lösungsweg vorzugeben
- Compiler oder Interpreter entscheidet, wie das Ziel erreicht wird.

__Funktionale Programmierung__

* rechnet mit Funktionen und vermeidet Zustandsänderungen sowie Seiteneffekte
* Betonung der Immutabilität von Daten
* Beispiele: Lisp, Haskell, Erlang

__Logische Programmierung__

* basiert auf mathematischer Logik und prädikatenlogischen Regeln
* Problembeschreibung erfolgt durch Fakten und Regeln
* Beispiel: Prolog

#### 0.7.2.3 Objektorientierte Programmierung

* Kapselung von Daten und dazugehörigen Methoden in Objekten
* Formulierung von Klassen
* zentrale Konzepte sind Kapselung, Vererbung und Polymorphie
* Fokus auf die Modellierung realer Entitäten und deren Interaktionen
* Beispiele: Java, C++, Python, C#