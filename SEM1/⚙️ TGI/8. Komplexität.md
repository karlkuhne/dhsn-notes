## 8.1 Grundbegriffe der Komplexitätstheorie

>Ein Algorithmus heißt effektiv, wenn er zielführend das gestellte Problem löst (ohne unnötige Umwege oder nicht gefragte Nebenergebnisse)

>Ein Algorithmus heißt effizient, wenn er ein gestelltes Problem mit möglichst geringem Aufwand (Ressourcenverbrauch) löst.

Messbare oder berechenbare Merkmale von Algorithmen
- Laufzeit
- Speicherbedarf
Speicherplatz kann auf Kosten der Rechenzeit (Laufzeit) gespart werden und umgekehrt kann Rechenzeit verkürzt werden durch Einsatz von mehr Speicher.

## 8.2 Laufzeitverhalten

* Die Laufzeit $T_A$ ist die Zeit, die ein Programm oder Algorithmus für eine Aufgabe benötigt
* Die **asymptotische Laufzeit** ist eine wichtige Klassifikation, die die Effizienz eines Algorithmus beschreibt, unabhängig von der konkreten Implementierung oder Hardware
* Ein Algorithmus hat **polynomielle Laufzeit**, wenn seine Laufzeit in $O(n^k)$ liegt (wobei $n$ die Größe des Inputs und $k$ eine Konstante ist)
  (gelten als handhabbar und effizient)
* Ein Algorithmus hat **exponentielle Laufzeit**, wenn seine Laufzeit nicht in $O(n^k)$ liegt
  (oft nicht mehr praktikabel, da sie zu lange dauern)
* Algorithmen mit einer Komplexität wie $O(\log^k n)$ sind besonders schnell

### 8.2.1 Drei Fälle der Laufzeitanalyse

* **Best-Case-Analyse**: Hier wird die kürzeste mögliche Laufzeit eines Algorithmus ermittelt (der günstigste Fall)
* **Average-Case-Analyse**: Hier wird die durchschnittliche Laufzeit berechnet, oft unter Berücksichtigung des Mittelwerts oder Erwartungswerts
* **Worst-Case-Analyse**: Hier wird die längste mögliche Laufzeit eines Algorithmus ermittelt (der ungünstigste Fall)

Bsp.: Die genaue Berechnung der Iterationen für Bubble-Sort im Durchschnittsfall (ohne Abbruch) ist sehr komplex:

$$ \left(\frac{n^2-n}{2}\right) - \frac{(n+1)\ln(n+1)}{2} + \left(\frac{n+1}{2}\right)\left[\ln 2 + \lim_{k \to \infty} \sum_{i=1}^k \frac{1}{i} - \ln k\right] + \frac{2}{3}\sqrt{2\pi(n+1)} + \frac{31}{36} + C $$

Für komplexere Algorithmen ist eine solch präzise Berechnung kaum machbar.

### 8.2.2 Beschreibung der Zeitkomplexität

* zeitliche Messungen sind in Einzelfällen von praktischer Relevanz, gelten aber nur für einen bestimmten Computertyp und sind nur bis zu einer bestimmten zeitlichen Grenze möglich
* theoretische Berechnungen sind maschinenunabhängig und beschreiben die Komplexität durch einen Term, der vom Umfang der Eingabedaten abhängt; sie sind in der Praxis bei konkreten Rahmenbedingungen weniger aussagekräftig

### 8.3 Komplexitätsmaße

* Komplexitätsmaße müssen für theoretische Betrachtungen unabhängig von der verwendeten Technologie sein
* statt der tatsächlichen Rechenzeit wird immer die Anzahl der Rechenschritte gezählt
* dazu wird ein möglichst einfaches Rechnermodell mit wenigen Befehlen verwendet, meistens die Turing-Maschine oder die Register-Maschine
* Turing-Maschinen können sehr verschieden definiert sein, und Rechenschritte können unterschiedlich lange dauern, aber die Rechenzeiten werden so grob gemessen, dass dies keine Rolle spielt
* die Kosten für jeden Rechenschritt werden mit 1 angesetzt, um ein uniformes dimensionsloses Komplexitätsmaß zu erhalten

## 8.4 Komplexität von Entscheidungsproblemen

* Entscheidungsprobleme können mit der Sprache der zu akzeptierenden Eingaben identifiziert werden
* Komplexitätsklassen werden über Sprachen definiert
* __Beispieldefinition__:
  Ein Entscheidungsproblem $L$ gehört genau dann zur Komplexitätsklasse P, wenn es eine Turing-Maschine gibt, die $L$ entscheidet, und eine Konstante $k \in \mathbb{N}$ existiert, für die die Laufzeit $t_M(n) = O(n^k)$ gilt
* für die Klasse NP wird „nichtdeterministisch“ an die Definition angefügt
* mit diesen Definitionen können Beweise in der Komplexitätstheorie über die Sprachen und die Konstruktion von Turing-Maschinen geführt werden
* nichtdeterministische Turing-Maschinen werden nur als Hilfsmittel für theoretische Betrachtungen benötigt

## 8.5 Polynomielle Reduktion (binäre Suche)

* viele Probleme sind Berechnungsprobleme (Bsp.: Optimierung), nicht nur Entscheidungsprobleme
* viele Optimierungsprobleme können mit polynomialem Aufwand in Entscheidungsprobleme umgewandelt werden
* dies geschieht oft durch Intervallhalbierung: man wählt eine obere Schranke $O$ und eine untere Schranke $U$ für den optimalen Wert. Dann wird geprüft, ob es eine bessere Lösung als $M = (O+U)/2$ gibt. Ist dies der Fall, wird $O$ auf $M$ gesetzt, andernfalls $U$ auf $M$
* es werden maximal $\log_2(O)$ Schritte benötigt, bis der gewünschte Wert erreicht ist
* auf diese Weise wird eine polynomiale Komplexität erreicht

## 8.6 O-Notation

* die O-Notation abstrahiert von konstanten und linearen Faktoren, was für theoretische Betrachtungen gerechtfertigt ist
* Bsp.: $23x^2 + 1037x + 107593$ ist asymptotisch $O(x^2)$ (für große $x$)
* Bsp.: $837 \cdot 2^n + 48690738$ ist asymptotisch $O(2^n)$ (für große $n$)
* die O-Notation beschreibt das asymptotische Verhalten von Funktionen, das wir speziell für Komplexitätsfunktionen anwenden
* eine Funktion $f$ ist **asymptotisch kleiner gleich** einer Funktion $g$, geschrieben $f \in O(g)$, wenn ein $n_0 > 0$ und eine Konstante $c$ existieren, sodass $|f(n)| \le c \cdot |g(n)|$ für alle $n > n_0$
* $f$ hat **polynomielle Laufzeit**, wenn $f \in O(n^k)$ für ein geeignetes $k > 0$
* $f$ hat **exponentielle Laufzeit**, wenn $f \in O(d^n)$ für ein geeignetes $d > 0$

## 8.7 Schrankenfunktionen

*   konstant $O(1)$ - Bsp.: Summe von $n$ Zahlen
*   logarithmisch $O(\log n)$ - Bsp.: schnelles Potenzieren
*   polylogarithmisch $O(\log^k n)$ für $k \ge 1$ - Bsp.: beste Heuristiken
*   linear $O(n)$ - Bsp.: Horner-Schema
*   n-log-n $O(n \log n)$ - Bsp.: Quicksort
*   quadratisch $O(n^2)$ - Bsp.: Bubble-Sort
*   polynomiell $O(n^k)$ für $k \ge 1$ - Bsp.: Matrizen-Multiplikation ($k=3$)
*   exponentiell $O(d^n)$ für $d > 1$ - Bsp.: Türme von Hanoi ($d=2$)

Für Logarithmen ist die Basiszahl im Zusammenhang mit Wachstumsklassen irrelevant, da alle Logarithmen proportional sind.

![[Pasted image 20260105150131.png]]
![[Pasted image 20260105150148.png]]

## 8.8 P und NP

__Klasse P (Polynomialzeit)__

>Entscheidungsprobleme, für die ein deterministischer Algorithmus existiert. Der Aufwand lässt sich als Polynom ausdrücken/ man findet eine Lösung in polynomialer Zeit.

(gelten als handhabbar und effizient)


__Klasse NP (Nichtdeterministische Polynomialzeit)__

>Entscheidungsprobleme, wo die gegebene Lösung (oder Lösungskandidat) kann in polynomialer Zeit auf ihre Korrektheit überprüft werden (Verifizierbarkeit)
>Alternativ: Es existiert ein nichtdeterministischer Algorithmus, der das Problem in polynomialer Zeit löst (z.B. durch „Raten“ der richtigen Lösung in jedem Schritt)

Für NP-Probleme ist oft kein deterministischer Algorithmus mit polynomialer Laufzeit bekannt. Stattdessen existieren oft nur Algorithmen mit exponentiellem Zeitaufwand

 (gelten oft als nicht handhabbar)

### 8.8.1 P-Klasse

Die Klasse P ist robust gegenüber Addition und Multiplikation (Abgeschlossenheit)
- Die polynomiale Komplexität bleibt auch bei verschiedenen Computern und Software-Paradigmen erhalten
- Eine polynomiale Reduktion eines Problems auf ein anderes Problem belässt das Problem in der Klasse P

In der Praxis gibt es kaum Probleme mit einem Aufwand, der größer ist als $O(n^3)$
- Probleme haben meistens höchstens Aufwand $O(n^3)$ oder exponentiellen Aufwand
- Bsp.: Die Multiplikation zweidimensionaler Matrizen hat einen Aufwand von $O(n^3)$

### 8.8.2 NP-Vollständigkeit

>NP-Probleme, die polynomialem Aufwand ineinander umgewandelt werden, werden als NP-vollständig bezeichnet

Bedingungen:
* Das Problem gehört zur Komplexitätsklasse NP
* Das Problem gehört genau dann zur Komplexitätsklasse P, wenn P = NP gilt (was als sehr unwahrscheinlich angesehen wird)

Die NP-vollständigen Probleme gelten als die schwersten Probleme in der Klasse NP.

Wenn eines dieser NP-vollständigen Probleme mit polynomialem Aufwand lösbar wäre, dann wären alle anderen NP-vollständigen Probleme auch in polynomialer Zeit lösbar (impliziert $P=NP$)

Es gibt aber auch Probleme, die in NP sind, aber nicht NP-vollständig (NP-intermediate). Dies wurde durch den **Satz von Ladner** mit einem künstlichen Beispiel gezeigt
**Kandidaten für NP-intermediate Probleme**:
- Primfaktorzerlegung (nicht bewiesen)
- Isomorphie-Problem bei Graphen
(aber noch nicht bewiesen)

### 8.8.3 Gilt P=NP ?

- Die Frage, ob P = NP ist (also ob jedes Problem, dessen Lösung schnell überprüft werden kann, auch schnell lösbar ist), ist eine der größten ungelösten Fragen in der theoretischen Informatik.
- Bei der Annahme, dass kein polynomialer Algorithmus für NP-Probleme existiert (was sehr wahrscheinlich ist), wären P und NP verschiedene Klassen

- Um die Frage zu klären, ob $P = NP$ gilt, muss entweder bewiesen werden, dass ein Problem in NP existiert, für das kein polynomialer Algorithmus gefunden werden kann (Folgerung: $P \ne NP$), oder dass für jedes Problem in NP ein polynomialer Algorithmus existiert (Folgerung: $P = NP$)
* Die Entdeckung eines deterministischen polynomialen Algorithmus für ein NP-vollständiges Problem hätte zur Folge, dass jedes NP-vollständige Problem deterministisch polynomial lösbar wäre
* Das Ziel ist die Klassifizierung der schwersten Probleme in NP

>Die Frage $P=NP$ ist bisher weder bewiesen noch widerlegt worden

__Aber:__
Seit August 2010 liegt ein 66-seitiger Beweis (1. Version) von Vinay Deolalikar vor, der die Aussage $P \ne NP$ belegt. Die Verifikation und Überarbeitung dieses Beweises laufen noch

![[Pasted image 20260106101211.png]]
Es ist klar, dass $P \subseteq NP$ gilt, die Frage nach $P = NP$ ist jedoch offen

![[Pasted image 20260119091123.png]]
![[Pasted image 20260119100356.png]]
## 8.9 Abgeschlossenheit und Anwendbarkeit

**Abgeschlossenheit**
- Werden zwei polynomiale Algorithmen nacheinander ausgeführt, ist der resultierende Gesamtaufwand weiterhin polynomial
- Wird ein Teil eines polynomialen Algorithmus durch ein Modul ersetzt, das selbst einen polynomialen Algorithmus enthält, ist der resultierende Gesamtaufwand ebenfalls polynomial

**Anwendbarkeit**
- Ein Algorithmus heißt praktisch anwendbar (*tractable*), wenn seine Laufzeit polynomial ist
- Ist die Laufzeit nicht polynomial, gilt er als praktisch nicht anwendbar (*intractable*)

## 8.10 Determinismus

>**Deterministischer Ablauf**: Eine eindeutige und feste Reihenfolge der Schritte ist vorgegeben

>**Deterministisches Ergebnis**: Bei denselben Eingaben wird immer das gleiche, eindeutige Ergebnis erreicht

* Auch nichtdeterministische Algorithmen können deterministische Ergebnisse liefern, Bsp.: Sortieren mit Quicksort (trotz verschiedener Wahl der Teilung bleibt das Ergebnis sortiert)
* Algorithmen mit einem deterministischen Ergebnis werden als deterministisch bezeichnet, unabhängig davon, ob ihr internes Verfahren deterministisch oder nichtdeterministisch ist

>**Nichtdeterministische Algorithmen**: Liefern bei gleichen Eingaben im Allgemeinen kein deterministisches Ergebnis

## 8.11 Komplexitätsklasse PSPACE

>Platzkomplexität ist der Speicherplatz, den ein Algorithmus braucht, um ein Problem zu lösen in Abhängigkeit von der Größe der Eingabe

* Ein Algorithmus braucht immer mindestens so viel Zeit wie Platz, da jeder Schreibvorgang im Speicher einen Rechenschritt benötigt
* Wichtige Platzkomplexitätsklassen sind $L=LOGSPACE$, $NL=NLOGSPACE$, $PSPACE$, $NPSPACE$, $EXPSPACE$
* $PSPACE$ ist die Klasse aller Entscheidungsprobleme, die eine deterministische Turingmaschine mit polynomialem Speicherplatz lösen kann
* $PSPACE$ ist größer als NP und umfasst die Klassen P und NP

### 8.11.1 PSPACE-vollständige Probleme

>Ein Problem ist $PSPACE$-vollständig, wenn es selbst in $PSPACE$ liegt und jedes andere Problem aus $PSPACE$ auf dieses Problem polynomial reduziert werden kann

* Bsp.: QBF (quantifizierte boolsche Formeln) ist PSPACE-vollständig
* QBF ist eine Erweiterung von SAT, bei der Formeln Quantoren enthalten
* QBF lässt sich nicht einfach in SAT umwandeln (reduzieren), ohne dass die Formellänge pro Quantor exponentiell wächst
* Daher ist eine direkte Überführung von QBF nach SAT nicht in P
* Bei vielen Zwei-Personen-Spielen kann man mit polynomialem Speicherplatz herausfinden, ob ein Spieler eine Gewinnstrategie hat
* Spiele wie Dame, Go, Hex, Schach, Sokoban werden bei Verallgemeinerung zu PSPACE-vollständigen Problemen
* Die PSPACE-Vollständigkeit ist ein Merkmal für interessante Spiele, da die Bestimmung einer Gewinnstrategie dann schwierig ist

### 8.11.2 Satz von Savitch (1970)

* $PSPACE$ ist die Klasse der Probleme, die von einer Turing-Maschine mit polynomialem Speicherplatz gelöst werden können
* $PSPACE$ kann auch mit Registermaschinen definiert werden, ohne die Klasse zu ändern
* Walter Savitch zeigte 1970, dass $PSPACE$ gleich bleibt, egal ob man deterministische oder nicht-deterministische Turing-Maschinen verwendet
* Dies ist anders als bei der Zeitkomplexität
* Savitch bewies, dass eine nicht-deterministische Turing-Maschine durch eine deterministische ersetzt werden kann, die nur quadratisch mehr Speicherplatz benötigt
* Das heißt, nicht-deterministischer Speicherplatz kann in deterministischen Speicherplatz mit nur geringfügig höherem Bedarf umgewandelt werden

