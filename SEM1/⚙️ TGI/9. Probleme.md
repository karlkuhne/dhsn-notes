## Begriffsklärung

- __Zweitseitig entscheidbar__: Es gibt einen Algorithmus, der
  bei JA-Instanzen hält und „JA“ sagt
  bei NEIN-Instanzen hält und „NEIN“ sagt
- __Einseitig entscheidbar__: Es gibt einen Algorithmus, der
  bei JA-Instanzen hält und „JA“ sagt
  bei NEIN-Instanzen möglicherweise nie hält

- __Klasse P__: Probleme, die in **polynomialer Zeit lösbar** sind
- __Klasse NP__: Probleme, bei denen eine **gegebene Lösung in polynomialer Zeit überprüfbar** ist
- __Klasse NP-vollständig__: Probleme in NP, lassen sich leicht auf **jedes andere NP-Problem überführen** (Lösung für eins: Lösung für alle)
- __Klasse NPI (intermediate)__: Probleme in NP, die **nicht NP-vollständig** sind

## Merke

Ein Problem ist immer entweder ein Entscheidungsproblem oder ein Berechnungsproblem.

Wenn ein Entscheidungsproblem weder einseitig noch einseitig entscheidbar ist, dann ist es nie
- Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
- LOOP-berechenbar / primitiv-rekursiv
- algorithmisch lösbar = berechenbar
- Alle Komplexitätsklassen (P, NP, NP-vollständig, NPI)

# 1. HALTE-Problem

>Angenommen: Ein Programm $H$ bestimmt immer korrekt, ob ein zu testendes Programm anhält oder nicht. Eine größere Maschine $D$ enthält $H$ und gibt zu testende Programme an es weiter. Was immer $H$ jeweils sagt, $D$ macht das Gegenteil davon. (Wenn das zu testende Programm unendlich läuft, halt $D$ an; wenn es hält, läuft $D$ unendlich.)
>Der Widerspruch tritt auf, wenn man $D$ sein eigenes Programm testen soll: Wenn $H$ sagt, dass $D$ anhält, dann läuft $D$ unendlich (weil es das Gegenteil macht).

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Hält das zu testende Programm?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $✗$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
   weil unentscheidbar (Satz von Turing, 1936)
- $✗$  LOOP-berechenbar / primitiv-rekursiv
  weil diese immer terminieren, Halte-Problem aber nicht total entscheidbar ist

- $✗$ algorithmisch lösbar = berechenbar
  weil kein Algorithmus für alle Eingaben korrekt entscheidet
- $✗$ zweiseitig entscheidbar
  weil keine totale Funktion existiert, die beide Fälle entscheidet
- $\checkmark$ Einseitig (partiell) entscheidbar
  weil man erkennt wenn Programm hält (aber nicht wenn es nicht hält)

- $✗$ Klasse P (polynominaler Aufwand)
  weil P nur entscheidbare Probleme enthält
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil NP nur entscheidbare Probleme enthält
- $✗$ Klasse NP-vollständig
  weil NP-v Teilmenge von NP ist
- $✗$ Klasse NPI (intermediate)
  weil NPI Teilmenge von NP ist

# 2. Busy-Beaver

>Das Busy Beaver Problem fragt: Was ist die maximale Anzahl von Einsen, die eine  $n$-Zustand-Turing-Maschine auf ein leeres Band schreiben kann, bevor sie anhält?
>Die Busy Beaver Funktion $BB(n)$ gibt diese maximale Anzahl für $n$ Zustände an. Das Problem ist: $BB(n)$ ist nicht berechenbar. Wenn wir $BB(n)$ berechnen könnten, könnten wir das Halte-Problem lösen (Widerspruch): Simuliere eine Maschine für $BB(n)$ Schritte - hält sie nicht bis dahin, läuft sie unendlich. Da $BB(n)$ schneller wächst als jede berechenbare Funktion, ist sie selbst nicht berechenbar.

- $✗$ Entscheidungsproblem
  weil es den Funktionswert $BB(n)$ berechnen soll, nicht Ja/Nein entscheiden
- $\checkmark$ Berechnungsproblem
  weil es den Funktionswert $BB(n)$ berechnen soll

- $✗$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil nicht berechenbar (wächst schneller als jede berechenbare Funktion)
- $✗$ LOOP-berechenbar / primitiv-rekursiv
  weil nicht berechenbar

- $✗$ algorithmisch lösbar = berechenbar
  weil kein Algorithmus $BB(n)$ für alle $n$ berechnen kann
- $✗$ zweiseitig entscheidbar
  weil nicht berechenbar
- $✗$ Einseitig (partiell) entscheidbar
  weil nicht einmal partiell berechenbar

- $✗$ Klasse P (polynominaler Aufwand)
  weil P nur entscheidbare Probleme enthält
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil NP nur entscheidbare Probleme enthält
- $✗$ Klasse NP-vollständig
  weil NP-v Teilmenge von NP ist
- $✗$ Klasse NPI (intermediate)
  weil NPI Teilmenge von NP ist

# 3. Postsches Korrespondenz-Problem (Domino)

>Das Postsche Korrespondenzproblem (PKP) fragt: Gegeben sind $n$ Paare von Wörtern, z.B. $(a, ab)$, $(b, ca)$, $(ca, a)$. Gesucht ist eine Folge dieser Paare, sodass die oberen Wörter aneinandergehängt dasselbe ergeben wie die unteren.

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Existiert eine Lösung für diese PKP-Instanz?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $✗$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil unentscheidbar (reduzierbar auf Halte-Problem)
- $✗$ LOOP-berechenbar / primitiv-rekursiv
  weil nicht entscheidbar

- $✗$ algorithmisch lösbar = berechenbar
  weil kein Algorithmus für alle Eingaben korrekt entscheidet
- $✗$ zweiseitig entscheidbar
  weil keine totale Funktion existiert, die beide Fälle entscheidet
- $\checkmark$ Einseitig (partiell) entscheidbar
  weil existierende Lösungen durch Ausprobieren gefunden werden können

- $✗$ Klasse P (polynominaler Aufwand)
  weil P nur entscheidbare Probleme enthält
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil NP nur entscheidbare Probleme enthält
- $✗$ Klasse NP-vollständig
  weil NP-v Teilmenge von NP ist
- $✗$ Klasse NPI (intermediate)
  weil NPI Teilmenge von NP ist

# 4. Kachelwand

>Das Kachelwand-Problem (Domino-Problem, Tiling Problem) fragt: Gegeben ist eine endliche Menge von quadratischen Kacheln mit farbig markierten Kanten. Existiert eine Methode, mit der man die unendliche Ebene kacheln kann, sodass aneinanderstoßende Kanten immer dieselbe Farbe haben? Kacheln dürfen beliebig oft verwendet, aber nicht gedreht werden. Es geht darum, ob ein wiederholbares Muster existiert.

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Kann die Ebene mit diesem Kachelset gekachelt werden?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $✗$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil unentscheidbar (Wang, 1961)
- $✗$ LOOP-berechenbar / primitiv-rekursiv
  weil nicht entscheidbar

- $✗$ algorithmisch lösbar = berechenbar
  weil kein Algorithmus für alle Kachelsets korrekt entscheidet
- $✗$ zweiseitig entscheidbar
  weil keine totale Funktion existiert, die beide Fälle entscheidet
- $\checkmark$ Einseitig (partiell) entscheidbar
  weil existierende Kachelungen durch systematisches Konstruieren gefunden werden

- $✗$ Klasse P (polynominaler Aufwand)
  weil P nur entscheidbare Probleme enthält
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil NP nur entscheidbare Probleme enthält
- $✗$ Klasse NP-vollständig
  weil NP-v Teilmenge von NP ist
- $✗$ Klasse NPI (intermediate)
  weil NPI Teilmenge von NP ist

# 5. Collatz-Zahlen (Syracuse-Vermutung)

>Die Collatz-Vermutung (Syracuse-Vermutung) fragt: Startet man mit einer beliebigen natürlichen Zahl $n$ und wendet wiederholt folgende Regel an - ist $n$ gerade, teile durch 2; ist $n$ ungerade, berechne $3n+1$ - erreicht man dann immer irgendwann die Zahl 1? Die Vermutung besagt ja, ist aber bis heute unbewiesen.

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Erreicht die Collatz-Folge von $n$ die Zahl 1?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $✗$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil (vermutlich) unentscheidbar, ob alle Zahlen bei 1 ankommen
- $✗$ LOOP-berechenbar / primitiv-rekursiv
  weil nicht entscheidbar

- $✗$ algorithmisch lösbar = berechenbar
  weil kein bekannter Algorithmus für alle Startwerte entscheidet
- $✗$ zweiseitig entscheidbar
  weil keine totale Funktion existiert, die beide Fälle entscheidet
- $\checkmark$ Einseitig (partiell) entscheidbar
  weil man durch Simulation erkennt wenn eine Zahl die 1 erreicht

- $✗$ Klasse P (polynominaler Aufwand)
  weil P nur entscheidbare Probleme enthält
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil NP nur entscheidbare Probleme enthält
- $✗$ Klasse NP-vollständig
  weil NP-v Teilmenge von NP ist
- $✗$ Klasse NPI (intermediate)
  weil NPI Teilmenge von NP ist

# 6. Conways Game of Life

>Conways Game of Life ist ein zellulärer Automat auf einem unendlichen Gitter. Jede Zelle ist entweder lebendig oder tot. In jedem Schritt wird der Zustand nach festen Regeln aktualisiert, abhängig von den Nachbarzellen: Eine lebende Zelle mit 2-3 lebenden Nachbarn überlebt, sonst stirbt sie. Eine tote Zelle mit genau 3 lebenden Nachbarn wird lebendig. Gegeben eine Startkonfiguration, kann man fragen: Wird eine bestimmte Zelle jemals lebendig?

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Wird Zelle $(x,y)$ jemals lebendig?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $✗$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil unentscheidbar (Game of Life ist Turing-vollständig)
- $✗$ LOOP-berechenbar / primitiv-rekursiv
  weil nicht entscheidbar

- $✗$ algorithmisch lösbar = berechenbar
  (wenn eine Zelle nie lebendig wird, können wir das nicht algorithmisch feststellen - wir müssten unendlich lange simulieren, um sicher zu sein)
- $✗$ zweiseitig entscheidbar
  weil keine totale Funktion existiert, die beide Fälle entscheidet
- $\checkmark$ Einseitig (partiell) entscheidbar
  weil man durch Simulation erkennt wenn eine Zelle lebendig wird

- $✗$ Klasse P (polynominaler Aufwand)
  weil P nur entscheidbare Probleme enthält
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil NP nur entscheidbare Probleme enthält
- $✗$ Klasse NP-vollständig
  weil NP-v Teilmenge von NP ist
- $✗$ Klasse NPI (intermediate)
  weil NPI Teilmenge von NP ist

# 7. Langton-Ameise

>Die Langton-Ameise ist ein zellulärer Automat: Eine "Ameise" bewegt sich auf einem unendlichen Gitter. Auf weißen Feldern dreht sie sich um 90° nach rechts, färbt das Feld schwarz und geht vorwärts. Auf schwarzen Feldern dreht sie sich um 90° nach links, färbt das Feld weiß und geht vorwärts. Gegeben eine Startkonfiguration, kann man fragen: Kehrt die Ameise jemals zu ihrer Ausgangsposition zurück?

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Kehrt die Ameise zur Startposition zurück?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $✗$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil unentscheidbar
- $✗$ LOOP-berechenbar / primitiv-rekursiv
  weil nicht entscheidbar

- $✗$ algorithmisch lösbar = berechenbar
  weil kein Algorithmus für alle Konfigurationen entscheidet
- $✗$ zweiseitig entscheidbar
  weil keine totale Funktion existiert, die beide Fälle entscheidet
- $\checkmark$ Einseitig (partiell) entscheidbar
  weil man durch Simulation erkennt wenn die Ameise zurückkehrt

- $✗$ Klasse P (polynominaler Aufwand)
  weil P nur entscheidbare Probleme enthält
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil NP nur entscheidbare Probleme enthält
- $✗$ Klasse NP-vollständig
  weil NP-v Teilmenge von NP ist
- $✗$ Klasse NPI (intermediate)
  weil NPI Teilmenge von NP ist

# 8. Ackermannfunktion

>Die Ackermannfunktion $A(m,n)$ ist eine Funktion, die zwei natürliche Zahlen als Eingabe nimmt und extrem schnell wächst. Sie ist berechenbar - es gibt einen Algorithmus, der für jede Eingabe den korrekten Wert berechnet und dabei immer terminiert.

- $✗$ Entscheidungsproblem
  weil es keinen Ja/Nein-Wert entscheidet
- $\checkmark$ Berechnungsproblem
  weil es den Funktionswert $A(m,n)$ berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil total berechenbar (Algorithmus terminiert immer)
- $✗$ LOOP-berechenbar / primitiv-rekursiv
  weil sie schneller wächst als jede primitiv-rekursive Funktion

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil ein Algorithmus $A(m,n)$ für alle Eingaben berechnet
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $✗$ Klasse P (polynominaler Aufwand)
  weil die Berechnung nicht in polynomialer Zeit möglich ist
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NP-vollständig
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NPI (intermediate)
  weil es kein Entscheidungsproblem ist

# 9. Turm von Hanoi

>Der Turm von Hanoi ist ein Puzzle mit drei Stäben und $n$ verschieden großen Scheiben. Anfangs liegen alle Scheiben sortiert (größte unten) auf einem Stab. Ziel ist es, den gesamten Turm auf einen anderen Stab zu bewegen. Regeln: Pro Zug darf nur eine Scheibe bewegt werden, und nie darf eine größere auf einer kleineren liegen. Das Problem fragt: Welche Zugfolge löst das Puzzle mit $n$ Scheiben?

- $✗$ Entscheidungsproblem
  weil es keine Ja/Nein-Frage ist
- $\checkmark$ Berechnungsproblem
  weil es die optimale Zugfolge berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil es einen Algorithmus gibt, der die Lösung berechnet
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil die Lösung mit primitiver Rekursion berechenbar ist

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil ein effizienter Algorithmus die Lösung für alle $n$ berechnet
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $✗$ Klasse P (polynominaler Aufwand)
  weil die Lösung $2^n - 1$ Züge benötigt (exponentiell)
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NP-vollständig
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NPI (intermediate)
  weil es kein Entscheidungsproblem ist

# 10. Primfaktorzerlegung (Faktorisierung)

>Die Primfaktorzerlegung fragt: Gegeben eine natürliche Zahl $n$, finde alle Primzahlen $p_1, p_2, ..., p_k$, sodass $n = p_1 \cdot p_2 \cdot ... \cdot p_k$. Jede natürliche Zahl hat genau eine solche Zerlegung. Es gibt Algorithmen, die dies berechnen können, aber für sehr große Zahlen sind die bekannten Algorithmen extrem langsam.

- $✗$ Entscheidungsproblem
  weil es keine Ja/Nein-Frage ist
- $\checkmark$ Berechnungsproblem
  weil es die Primfaktoren von $n$ berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil es Algorithmen gibt, die die Faktoren berechnen
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil mit primitiver Rekursion berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil Algorithmen die Primfaktoren für alle $n$ berechnen können
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $✗$ Klasse P (polynominaler Aufwand)
  weil kein polynomialer Algorithmus bekannt ist
- $\checkmark$ Klasse NP (nichtdeterministisch polynomial)
  weil eine gegebene Lösung in polynomialer Zeit verifizierbar ist
- $✗$ Klasse NP-vollständig
  weil nicht NP-vollständig (wahrscheinlich in NPI)
- $\checkmark$ Klasse NPI (intermediate)
  weil vermutlich weder in P noch NP-vollständig

# 11. Traveling Salesman

## 11.11 $TS_k$

>Das Traveling Salesman Problem (TSP) fragt: Gegeben sind $n$ Städte mit Abständen zwischen ihnen und eine Zahl $k$. Gibt es eine Rundreise, die jede Stadt genau einmal besucht und wieder zum Start zurückkehrt, mit einer Gesamtlänge $\leq k$? Es ist leicht zu überprüfen, ob eine gegebene Route die Bedingung erfüllt (polynomial), aber schwer, eine solche Route zu finden (kein polynomialer Algorithmus bekannt).

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Existiert eine Rundreise mit Länge $\leq k$?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil es Algorithmen gibt, die alle Routen durchprobieren können
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil mit primitiver Rekursion berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil ein Algorithmus für alle Eingaben korrekt entscheidet
- $\checkmark$ zweiseitig entscheidbar
  weil ein Algorithmus beide Fälle (Ja/Nein) in endlicher Zeit entscheidet
- $✗$ Einseitig (partiell) entscheidbar
  weil es sogar zweiseitig entscheidbar ist

- $✗$ Klasse P (polynominaler Aufwand)
  weil kein polynomialer Algorithmus bekannt ist
- $\checkmark$ Klasse NP (nichtdeterministisch polynomial)
  weil eine gegebene Route in polynomialer Zeit verifizierbar ist
- $\checkmark$ Klasse NP-vollständig
  eines der klassischen NP-vollständigen Probleme
- $✗$ Klasse NPI (intermediate)
  weil TSP NP-vollständig ist

## 11.2 $TS_o$

>Gegeben sind $n$ Städte mit Abständen zwischen ihnen. Finde die kürzeste Rundreise, die jede Stadt genau einmal besucht und wieder zum Start zurückkehrt. Im Gegensatz zur Entscheidungsvariante ($TS_k$) wird hier nicht nur gefragt ob eine Route existiert, sondern welche die optimale ist. Dies ist ein NP-hartes Optimierungsproblem.

- $✗$ Entscheidungsproblem
  weil es die optimale Route berechnen soll, nicht Ja/Nein entscheiden
- $\checkmark$ Berechnungsproblem
  weil es die kürzeste Rundreise berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil es Algorithmen gibt, die alle Routen durchprobieren können
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv 
  weil mit primitiver Rekursion berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil ein Algorithmus für alle Eingaben die optimale Route findet
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $✗$ Klasse P (polynominaler Aufwand)
  weil kein polynomialer Algorithmus bekannt ist
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil NP nur Entscheidungsprobleme enthält
- $✗$ Klasse NP-vollständig
  weil NP-vollständig nur Entscheidungsprobleme enthält (aber NP-schwer)
- $✗$ Klasse NPI (intermediate)
  weil es kein Entscheidungsproblem ist

# 12. Goldbach-Vermutung

>Die Goldbach-Vermutung besagt: Jede gerade Zahl größer als 2 lässt sich als Summe zweier Primzahlen darstellen (z.B. $8 = 3 + 5$, $20 = 13 + 7$). Die Vermutung ist bis heute unbewiesen. Das zugehörige Entscheidungsproblem fragt: Gilt die Goldbach-Vermutung für eine gegebene gerade Zahl $n$?

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Lässt sich $n$ als Summe zweier Primzahlen darstellen?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil ein Algorithmus alle Primzahlpaare durchprobieren kann
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil mit primitiver Rekursion berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil ein Algorithmus für jede gerade Zahl entscheidet
- $\checkmark$ zweiseitig entscheidbar
  weil ein Algorithmus beide Fälle in endlicher Zeit entscheidet
- $✗$ Einseitig (partiell) entscheidbar
  weil es sogar zweiseitig entscheidbar ist

- $✗$ Klasse P (polynominaler Aufwand)
  weil kein polynomialer Algorithmus bekannt ist
- $\checkmark$ Klasse NP (nichtdeterministisch polynomial)
  weil ein gegebenes Primzahlpaar in polynomialer Zeit verifizierbar ist
- $\checkmark$ Klasse NP-vollständig
  weil als NP-vollständig bekannt
- $✗$ Klasse NPI (intermediate)
  weil vermutlich nicht in NPI (könnte sogar in P sein)

# 13. Sudoku (beliebiger Größe)

>Sudoku fragt: Gegeben ist ein teilweise ausgefülltes $n \times n$ Gitter (für Standard-Sudoku ist $n=9$). Kann man die leeren Felder so mit Zahlen füllen, dass in jeder Zeile, jeder Spalte und jedem Block jede Zahl genau einmal vorkommt?

- $✗$ Entscheidungsproblem
  weil es die Lösung berechnen soll, nicht nur Ja/Nein entscheiden
- $\checkmark$ Berechnungsproblem
  weil es die vollständige Belegung des Gitters berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil Algorithmen existieren, die alle Möglichkeiten durchprobieren
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil mit primitiver Rekursion berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil Algorithmen für alle Eingaben eine Lösung finden oder feststellen dass keine existiert
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $✗$ Klasse P (polynominaler Aufwand)
  weil kein polynomialer Algorithmus bekannt ist
- $\checkmark$ Klasse NP (nichtdeterministisch polynomial)
  Eine vorgeschlagene Lösung lässt sich schnell überprüfen, aber das Finden einer Lösung kann exponentiell lange dauern.
- $\checkmark$ Klasse NP-vollständig
  weil Sudoku NP-vollständig ist
- $✗$ Klasse NPI (intermediate)
  weil Sudoku NP-vollständig ist, nicht intermediate

# 14. Matrizenmultiplikation

>Matrizenmultiplikation fragt: Gegeben sind zwei Matrizen $A$ und $B$, berechne das Matrixprodukt $C = A \cdot B$. Die naive Methode benötigt $O(n^3)$ Operationen für $n \times n$ Matrizen. Es gibt effizientere Algorithmen wie Strassen ($O(n^{2.807})$) oder noch bessere.

- $✗$ Entscheidungsproblem
  weil es keine Ja/Nein-Frage ist
- $\checkmark$ Berechnungsproblem
  weil es die Produktmatrix $C$ berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil einfache Algorithmen zur Berechnung existieren
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil mit verschachtelten Schleifen (LOOP) berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil Algorithmen das Produkt für alle Matrixpaare berechnen
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $\checkmark$ Klasse P (polynominaler Aufwand)
  weil in $O(n^3)$ oder besser lösbar (polynomial)
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NP-vollständig
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NPI (intermediate)
  weil es kein Entscheidungsproblem ist

# 15. Lösung Linearer Gleichungssysteme

>Die Lösung linearer Gleichungssysteme fragt: Gegeben ist ein System von $n$ linearen Gleichungen mit $n$ Variablen (in Matrixform $Ax = b$), berechne den Lösungsvektor $x$. Dies kann effizient mit Algorithmen wie Gauß-Elimination gelöst werden, die in polynomialer Zeit ($O(n^3)$) arbeiten.

- $✗$ Entscheidungsproblem
  weil es keine Ja/Nein-Frage ist
- $\checkmark$ Berechnungsproblem
  weil es den Lösungsvektor $x$ berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil Algorithmen wie Gauß-Elimination existieren
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil mit verschachtelten Schleifen berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil Algorithmen die Lösung für alle Systeme berechnen
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $\checkmark$ Klasse P (polynominaler Aufwand)
  weil mit Gauß-Elimination in $O(n^3)$ lösbar (polynomial)
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NP-vollständig
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NPI (intermediate)
  weil es kein Entscheidungsproblem ist

# 16. Sortierverfahren

>Sortierverfahren fragen: Gegeben ist eine Liste von $n$ Elementen, bringe sie in aufsteigende (oder absteigende) Reihenfolge. Es gibt viele Sortieralgorithmen mit unterschiedlicher Effizienz.

- $✗$ Entscheidungsproblem
  weil es keine Ja/Nein-Frage ist
- $\checkmark$ Berechnungsproblem
  weil es die sortierte Liste berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil viele Sortieralgorithmen existieren
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil mit verschachtelten Schleifen berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil Algorithmen jede Liste sortieren können
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $\checkmark$ Klasse P (polynominaler Aufwand)
  weil in $O(n \log n)$ lösbar (polynomial)
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NP-vollständig
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NPI (intermediate)
  weil es kein Entscheidungsproblem ist

# 17. Suchverfahren

>Suchverfahren fragen: Gegeben ist eine Liste von $n$ Elementen und ein Suchwert, finde die Position des Suchwerts in der Liste (oder stelle fest, dass er nicht vorhanden ist).

- $✗$ Entscheidungsproblem
  weil es keine Ja/Nein-Frage ist (sondern Position)
- $\checkmark$ Berechnungsproblem
  weil es die Position des gesuchten Elements berechnen soll

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil einfache Suchalgorithmen existieren
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil mit Schleifen berechenbar

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil Algorithmen das Element in jeder Liste finden können
- $✗$ zweiseitig entscheidbar
  weil es kein Entscheidungsproblem ist
- $✗$ Einseitig (partiell) entscheidbar
  weil es kein Entscheidungsproblem ist

- $\checkmark$ Klasse P (polynominaler Aufwand)
  weil in $O(n)$ oder $O(\log n)$ lösbar (polynomial)
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NP-vollständig
  weil es kein Entscheidungsproblem ist
- $✗$ Klasse NPI (intermediate)
  weil es kein Entscheidungsproblem ist

# 18. Schach und GO

>Schach fragt: Gegeben ist eine Spielstellung auf einem $n \times n$ Brett, hat Weiß eine Gewinnstrategie? Für verallgemeinertes Schach auf $n \times n$ Brettern ist es härter als NP - selbst mit nichtdeterministischem Raten wäre die Verifikation zu langsam (exponentiell).

>Go fragt: Gegeben ist eine Spielstellung auf einem $n \times n$ Brett, hat Schwarz eine Gewinnstrategie? Für verallgemeinertes Go auf $n \times n$ Brettern ist es noch schwerer als NP - die Komplexität liegt im exponentiellen oder Speicherplatz-begrenzten Bereich.

- $\checkmark$ Entscheidungsproblem
  weil Ja/Nein-Frage: "Hat Weiß eine Gewinnstrategie?"
- $✗$ Berechnungsproblem
  weil es eine Entscheidung erfordert, keinen Funktionswert berechnet

- $\checkmark$ Turing-berechenbar / μ-rekursiv / WHILE/GOTO-berechenbar
  weil durch Durchsuchen aller möglichen Züge entscheidbar
- $\checkmark$ LOOP-berechenbar / primitiv-rekursiv
  weil die Anzahl möglicher Stellungen endlich ist

- $\checkmark$ algorithmisch lösbar = berechenbar
  weil ein Algorithmus alle Zugfolgen durchprobieren kann
- $\checkmark$ zweiseitig entscheidbar
  weil ein Algorithmus beide Fälle in endlicher Zeit entscheidet
- $✗$ Einseitig (partiell) entscheidbar
  weil es sogar zweiseitig entscheidbar ist

- $✗$ Klasse P (polynominaler Aufwand)
  weil EXPTIME-vollständig (exponentiell)
- $✗$ Klasse NP (nichtdeterministisch polynomial)
  weil EXPTIME-vollständig (härter als NP)
- $✗$ Klasse NP-vollständig
  weil EXPTIME-vollständig (außerhalb von NP)
- $✗$ Klasse NPI (intermediate)
  weil EXPTIME-vollständig (außerhalb von NP)