## 5.1 Gültigkeit und Lebensdauer

![[Pasted image 20251203134329.png]]

## 5.2 Speicherklassen

- __auto__: Variablen werden automatisch auf dem Stack auf- und abgebaut, auto ist die Standardannahme
- __static__: Variablen existieren über die gesamte Laufzeit
- __extern__: Variable ist in einem anderen Modul global definiert, sie wird hier nur bekannt gemacht
- __register__: Die Variable soll besonders schnell sein, es wird versucht, sie in einem Prozessorregister zu halten
- __volatile__: Die Variable wird von parallel (quaisiparallel) ablaufenden Programmteilen (z.Bsp. Interruptroutine) benutzt. Sie wird nicht (auch nicht temporär) in Registern gehalten
- Die Speicherklasse wird, wenn sie angegeben werden soll, vor dem Typ der Variablen angegeben

#### 5.2.1 auto

>This is the default storage class for all the variables declared inside a function or a block. Auto variables can be only accessed within the block/function they have been declared and not outside them (which defines their scope).

```run-c
#include <stdio.h>

int main() {
  
    // auto is optional here, as it's the default storage class
    auto int x = 10;  
    printf("%d", x);
    return 0;
}
```

### 5.2.2 static

>In C programming, a __static__ variable is declared using static keyword and have the property of retaining their value between multiple function calls. It is initialized only once and is not destroyed when the function returns a value. It extends the lifetime of the variable till the end of the program.

```run-c
#include <stdio.h>

// Function with static variable
int fun(){
    static int count = 0;
    count++;
    return count;
}
int main(){
    printf("%d ", fun());
    printf("%d ", fun());
    return 0;
}
```

### 5.2.3 extern

>In C, the __extern__ keyword is used to declare a variable or a function whose definition is present in some other file. Basically, it extends the visibility of the variables and functions in C to multiple source files.

```c
// src.c
int ext_var = 22;
```

```c
// main.c
#include <stdio.h>

extern int ext_var;

void printExt() {
  	printf("%d", ext_var);
}
int main() {
    printExt();
    return 0;
}
```


## 5.3 Arrays als Parameter

- Arrays können nicht als Parameter an Funktionen übergeben werden
- Soll ein Array an eine Funktion übergeben werden, so wird grundsätzlich nur die Anfangsadresse übergeben
- Die Anzahl der Arrayelemente bleibt der Funktion dabei unbekannt

- Deshalb ist die Länge des Arrays grundsätzlich gesondert zu übergeben (Strings bilden hier eine Ausnahme, da die Länge durch die terminierende 0 bestimmt ist
- Es ist zu beachten, dass Arrays bei der Übermittlung an Funktionen nicht kopiert werden: Alle Änderungen an einem Array in einer Funktion vollziehen sich an den originalen Daten

- bei return wird nur die Adresse des zurückzugebenden Arrays übermittelt
- Hierbei ist auf die Lebensdauer des Arrays, dessen Adresse zurückgegeben wird, zu achten

```run-c
#include <stdio.h>

char buf[128];

// Zeiger auf die Speicheradresse von array, braucht für Arrays als Parameter
void sort (int* parray, int n)
{
  int i, j;
  for(i=0; i<n-1; i++)
    for(j=i+1; j<n; j++)
      if (parray[i]>parray[j])
      {
        parray[i]^=parray[j];
        parray[j]^=parray[i];
        parray[i]^=parray[j];
      }
}

int main()
{
  int array[]={9,5,1,2,7,3};
  int n=sizeof array/sizeof(int);
  int i;

  for(i=0; i<n; i++)
    printf("array[%d]:%d\n", i,array[i]);

  puts("==========");
  sort(array,n);
  for(i=0; i<n; i++)
    printf("array[%d]:%d\n", i,array[i]);

  return 0;
}
```

## 5.4 Parameter von main

- die `main`-Funktion kann auch Parameter haben
- es sind die Kommandozeilenparameter, sie erlauben Argumente beim Start des Programms an das Programm zu übergeben
- der erste Parameter ist vom Typ int (argc) und beinhaltet die Anzahl der Kommandozeilenparameter
- der zweite Parameter ist ein Pointer auf ein Array von Zeichenketten (`argv[]`)

- das Argument mit dem Index 0 ist immer der Programmaufruf selbst, danach folgen die übergebenen Argumente
```run-c
#include <stdio.h>

int main(int argc, char*argv[])
{
    int i;

    for(i=0; i<argc; i++)
    {
        printf("argv[%d]: %s\n",i,argv[i]);
    }
    return 0;
}
```
```text
$./a.out hans otto 73
argv[0]: ./a.out
argv[1]: hans
argv[2]: otto
argv[3]: 73
```

- Bsp.: Berechnung der Fakultät mit Kommandozeilenparameter
```run-c
#include <stdio.h>
#include <stdlib.h> // für exit(), atoi()

long fakult(int x)
{
    long f=1;
    int j;
    for(j=1; j<=x;j++) f*=j;
    //while (x>1) f*=x--; // short version !!
    return f;
}

int main(int argc, char* argv[])
{
    long f;
    int x;
    // Test, ob Argumente angegeben wurden sind
    if (argc != 2)
    {
        // Fehlermeldung und Programmabbruch
        printf("usage: %s <numeral>\n",argv[0]);
        exit (-1);
    }
    x=atoi(argv[1]);
    f=fakult(x);
    printf("Fakultaet von %d: %ld\n",x,f);
    return 0;
}
```
```text
$./a.out 3
Fakultaet von 3: 6
```

- das erste Kommandozeilenargument ist immer der Programmname selbst
- sollen Kommandozeilenargumente verwendet werden, so ist als erstes immer zu prüfen, ob diese beim Aufruf angegeben worden sind
- ist das nicht der Fall, sollte eine Fehler- oder Usage-Meldung ausgegeben werden (Bsp.: Zeile 17, 18 im vorherigen Code-Bsp.)