>Speicher nicht fest belegt sondern wird bedarfsgerecht vergeben

## 11.1 Speicheraufteilung

__Lesbar:__
Codesegment/Textsegment
  (Programmcode)

__Les- und schreibbar:__
besteht aus:
- Stacksegment
  (lokale und statische Variable (bereits Initialisiert und leben für gesamte Laufzeit))
- Datensegment
  (dynamischer Speicher oder heap (Speicherbereich, aus dem man Speicher bedarfsgerecht entnehmen und wieder zurücknehmen kann))

![[Pasted image 20260114095823.png]]

Zum Reservieren von Speicher braucht man die Funktion `malloc`
Man gibt die gewünschte Größe in Bytes als Parameter an, es returned einen Pointer auf den Speicher.

Mit `free` kann man wiederum diesen Speicher dem System zurückgeben.
Dabei muss man genau den Pointer wieder zurückgeben.

Mit `realloc`kann man unter Angabe der Adresse des originalen Speicherbereichs den Speicher vergrößern.
Wenn möglich geschieht das an der selben Stelle. Wenn da kein Platz ist, wird ein neuer Speicherblock erfasst, die Daten dahin kopiert und der neue Speicherblock freigegeben.

__void*__
- generischer Pointer
- mit keinem Datentyp assoziiert

###  11.1.1 Beispiel

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char buf[128];

typedef struct {
    char name[30 + 1];
    int matrNr;
    float noteKl;
    int noteBel;
} tStud;


void displayStudent(tStud* s) {
    printf("%-30s, %6d, %3.1f, %d\n",
           s->name,
           s->matrNr,
           s->noteKl,
           s->noteBel);
}

// Funktion zum Erstellen einer neuen Studenten-Struktur
tStud getStudent() {
    tStud st;
    printf("%-10s: ", "Name");
    // Liest die Eingabe in den globalen Puffer
    fgets(buf, 32, stdin);
    // Entfernt das Zeilenumbruchzeichen ('\n'), das fgets hinzufügt
    buf[strlen(buf) - 1] = 0;  
    // Kopiert den String aus dem Puffer in den Namen der Struktur
    strcpy(st.name, buf);      

    // Matrikelnummer eingeben
    printf("%-10s: ", "MatrikelNr");
    fgets(buf, 32, stdin);
    st.matrNr = atoi(buf);
  
    st.noteKl = 0;
    st.noteBel = 0;

    return st;
}

int main(int argc, char** argv) {
	// Steuerzeichen für die Schleife: 'j' für "ja, weiter"
    char proceed = 'j';
    // Pointer auf ein Array von tStud-Strukturen auf dem Heap
    tStud *pdata = NULL;
    // Temporärer Pointer, um den Rückgabewert von realloc zu speichern
    tStud *ptmp;
    
    int count = 0;
    int i;

    do {
	// Dynamische Speicherverwaltung: realloc versucht, den Speicherbereich zu erweitern. Der neue Bereich soll Platz für (count + 1) tStud-Strukturen bieten. 
	
	// Wenn pdata NULL ist (beim ersten Durchlauf), verhält sich realloc wie malloc. Es versucht, einen neuen Speicherbereich zu allozieren.
        ptmp = realloc(pdata, sizeof(tStud) * (count + 1));

        if (ptmp) {
	        // Wenn erfolgreich, zeigt pdata nun auf den (neuen) Speicherbereich
            pdata = ptmp;
            pdata[count] = getStudent();
            count++;
        } else {
            fprintf(stderr, "Fehler: Speicher konnte nicht neu zugewiesen werden.\n");
            break;
        }

        printf("Weitere Eingabe von Daten (j/n): ");
        // Die Antwort in den globalen Puffer les
        fgets(buf, 128, stdin);
        proceed = buf[0];

    } while (proceed == 'j');

    // Alle eingelesenen Studentendaten nacheinander anzeigen
    for (i = 0; i < count; i++) {
        // displayStudent erwartet einen Pointer
        // pdata + i ist Pointer-Arithmetik und entspricht der Adresse des i-ten Elements im Array (also &pdata[i]).
        displayStudent(pdata + i);
    }

    free(pdata);
    return 0;
}
```

Nachteil:
- relativ großer zusammenhängender Speicherbereich
- wenn der knapp wird, ist es schwierig, einen noch größeren zu bekommen

### 11.1.2 Beispiel 2

- Der Student wird in Beipiel 2 sofort in einem eigenen Speicherbereich erfasst. Die Variable st in getStudent entfällt.
- Es wird nur noch ein Pointer zurückgegeben und in main zugewiesen (viel effizienter).
- In Beipiel 2 wird ein Pointerarray eingeführt, das ebenfalls dynamisch erzeugt wird und mittels realloc „wächst“.
- Die Studenten können nun irgendwo im Speicher gestreut liegen, Sie werden über das Pointerarray verwaltet.
- Will man die Daten sortieren, so müssen nur die Pointer sortiert werden, was viel effizienter ist, als die Daten selbst zu sortieren

```c
tStud* getStudent() {
    // 'malloc' allokiert die Größe einer 'tStud'-Struktur auf dem Heap
    // und gibt einen 'void*'-Pointer zurück, der hier zu 'tStud*' gecastet wird.
    tStud* ps = malloc(sizeof(tStud));

    if (ps) {
        printf("%-10s: ", "Name");
        fgets(buf, 32, stdin);
        buf[strlen(buf) - 1] = 0;
        strcpy(ps->name, buf);

        printf("%-10s: ", "MatrikelNr");
        fgets(buf, 32, stdin);
        ps->matrNr = atoi(buf);

        ps->noteKl = 0;
        ps->noteBel = 0;
    }
    return ps;

int main(int argc, char** argv) {
    char proceed = 'j';

	// Deklaration des Pointers auf das dynamische Array von tStud-Pointern.
    tStud **pdata = NULL;
    // Temporärer Pointer für die Erweiterung des Pointer-Arrays mit realloc.
    tStud **ptmp;    
    // 'pstud' ist ein Pointer auf eine einzelne tStud-Struktur, die von getStudent zurückgegeben wird.
    tStud *pstud = NULL;
    
    int count = 0;
    int i;

    do {
        // Ruft getStudent auf, das nun einen Pointer auf eine *neu* auf dem Heap allokierte tStud-Struktur zurückgibt.
        pstud = getStudent();
        
        if (pstud) {
            ptmp = realloc(pdata, sizeof(tStud*) * (count + 1));

            if (ptmp) {
                pdata = ptmp;
                pdata[count] = pstud;
                count++;
            } else {
                fprintf(stderr, "Fehler: Speicher für Pointer-Array konnte nicht neu zugewiesen werden.\n");
                free(pstud);
                break;
            }
        } else {
            fprintf(stderr, "Fehler: Speicher für neuen Studenten konnte nicht zugewiesen werden.\n");
            break;
        }

        printf("Weitere Eingabe von Daten (j/n): ");
        fgets(buf, 128, stdin);
        proceed = buf[0];

    } while (proceed == 'j');

    for (i = 0; i < count; i++) {
        displayStudent(pdata[i]);
    }

    // Speicherfreigabe:
    // 1. Zuerst müssen alle individuell allokierten tStud-Strukturen freigegeben werden, auf die die Pointer im 'pdata'-Array zeigen.
    for (i = 0; i < count; i++) {
        free(pdata[i]);
    }
    // 2. Danach muss das 'pdata'-Array selbst freigegeben werden, das die Pointer gespeichert hat.
    free(pdata);

    return 0;
}
```

## 11.2 Verkettete Liste

* jeder Datensatz (wie unsere Studenten-Struktur) bekommt ein zusätzliches Feld, das wir `next` nennen.
* dieses `next`-Feld ist ein Zeiger, der immer auf den **nächsten** Datensatz in der Liste zeigt.
* der Vorteil ist, dass die einzelnen Datensätze nicht wie bei einem großen Array zusammenhängend im Speicher liegen müssen. Sie können überall im Speicher verteilt sein.
* um durch alle Datensätze zu gehen, folgt man einfach diesen `next`-Zeigern von einem Datensatz zum nächsten.

### 11.2.1 Beispiel 1

- Hier ist der einfachste Fall einer verketteten Liste implementiert.
- Eine Zeigervariable zeigt auf den ersten Datensatz.
- Jeder neue Datensatz wird unmittelbar hinter diesem Zeiger in die Liste eingefügt:
  `ptmp->next= pdata; pdata=ptmp;`
- Dies Liste zeigt ein Stackverhalten, die Reihenfolge der Daten wird hier invertiert

```c
int main(int argc, char** argv)
{
    char proceed = 'j';
    tStud * pdata = NULL;
    tStud * ptmp;
    int count = 0;
    int i;
    
    do
    {
        ptmp = getStudent();
        if (ptmp)
        {
            // Das neue Element wird an den Anfang der Liste eingefügt (prepend). Der 'next'-Pointer des neuen Elements zeigt auf das aktuelle Listenelement, das zuvor der Kopf der Liste war (oder NULL, wenn die Liste leer war).
            ptmp->next = pdata;
            // Das neue Element wird zum neuen Kopf der Liste.
            pdata = ptmp;
        } else {
            perror(NULL);
        }
        printf("Weitere Eingabe von Daten (j/n) : ");
        fgets(buf, 128, stdin);
        proceed = buf[0];

    } while (proceed == 'j');
    
    // Daten ausgeben
    for (ptmp = pdata; ptmp ; ptmp = ptmp->next) displayStudent(ptmp);
    
    // Speicherfreigabe: Alle Elemente der verketteten Liste müssen freigegeben werden. Iteriert, solange der Kopf (pdata) nicht NULL ist.
    while (pdata) {
        // 'ptmp' speichert den Pointer zum nächsten Element, BEVOR das aktuelle 'pdata' freigegeben wird.
        ptmp = pdata->next;
        // Das aktuelle Element freigeben.
        free(pdata);
        // 'pdata' auf das nächste Element verschieben.
        pdata = ptmp;
    }
    return 0;
}
```

- Die Daten werden genau verkehrt herum ausgegeben.
- Der untere Kasten zeigt die Ausgabe der Daten (erste Zeile)
- Und das Wiederfreigeben des ausgefassten Speichers

### 11.2.2 Beispiel 2

- Erweitert man das Ganze um einen weiteren Zeiger pLast, kann man eine Liste bauen, bei der jeder neue Datensatz hinten angefügt wird.
- Eine solche Liste zeigt das Verhalten einer Warteschlange.
- Hier werden die Daten in der Reihenfolge der Eingabe auch ausgegeben.

```c
int main(int argc, char** argv)
{
    char proceed = 'j';
    // Pointer auf den ersten Datensatz der Liste (Kopf), initialisiert auf NULL
    tStud * pdata = NULL;
    // Pointer auf den letzten Datensatz der Liste (Ende), initialisiert auf NULL
    tStud * plast = NULL;
    tStud * ptmp;
    int count = 0;
    int i;
    
    do
    {
        ptmp = getStudent();
        if (ptmp)
        {
            // Logik zum Hinzufügen des neuen Studenten (ptmp) am Ende der verketteten Liste (Warteschlangen-Verhalten)
            
            // Wenn die Liste aktuell leer ist (dies ist der erste Student)
            if (pdata == NULL) 
	            // Wird der neue Student zum Kopf der Liste
                pdata = ptmp;
            
            // Wenn die Liste NICHT leer ist
            if (plast)         
	            // Zeigt der 'next'-Pointer des bisherigen letzten Elements auf den neuen Studenten
                plast->next = ptmp;
            
            // Der neue Student wird immer das neue letzte Element der Liste
            plast = ptmp;      
        }
        else {
            perror(NULL);
        }
        printf("Weitere Eingabe von Daten (j/n) : ");
        fgets(buf, 128, stdin);
        proceed = buf[0];
    }
    
    while (proceed == 'j');
    // . . . Ausgabe, wie vorher
    return 0;
}
```

- Es wird immer am Listenende ein neuer Datensatz angefügt, in dem der Inhalt von pLast ind den neuen Datensatz übernommen und pLast auf den neuen Datensatz gestellt wird.
- Bei Aufnahme des ersten Datensatzes muss pData zusätzlich den Pointer des neuen Datensatzes bekommen

### 11.2.2 Beispiel 3

```c
#include <stdio.h
#include <stdlib.h>

char* vdata[] = {"Franz", "Paul", "Peter", "Max"}

typedef struct tLEAF {
	struct tLEAF * pl;
	struct tLEAF * pr;
	void * pdata;
}tleaf;

tleaf leafNull = {};

void addToTree(tlead* pt, void* pdata) {
	if (pt->pdata==NULL)
		pt->pdata=pdata;
	else
		strcpm(((char*)pt->pdata, (char*)pdata)>0) {
			// left
			if(pt->pl==NULL) {
				pt->pl=malloc(sizeof(tleaf));
				*(pt->pl)=leafNull;
			}
			addToTree(pt->pl, pdata);
		} else {
			// right
			if(pt->pr==NULL) {
				pt->pr=malloc(sizeof(tleaf));
				*(pt->pr)=leafNull;
			}
			addToTree(pt->pr, pdata);
		}
}

void dispTree(tleaf *pt) {
	if (pt->pl)
		dispTree(pt->pl);
	puts((char*)(pt->pdata));
	if (pt->pr)
		dispTree(pt->pr)
}

int main() {
	tleaf *root = malloc(sizeof(tleaf));
	*root = leafNull;
	for(int i=0; i<sizeof vdata/sizeof vdata[0]; i++)
		addToTree(root, vdata[i]);
	disptree(root);
}
```


- memcpy
- memmove
- strcpy
- strncpy
- strcat