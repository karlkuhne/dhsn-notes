- Pointer sind Adressen von Daten
- Da Daten immer von einem bestimmten Typ sind, sind auch Pointer an einen Datentyp gebunden
- Pointervariablen sind Variable, die als Wert die Adresse einer anderen Variablen enthalten, sie werden mit einem * vereinbart

- Die Adresse einer Variablen wird mit einem vorangestellten & gebildet
- Ein * vor einem Pointer ist der Dereferenzierungsoperator. Er liefert den Wert, auf den ein Pointer zeigt
- Pointer werden in printf mit %p ausgegeben

```run-c
#include <stdio.h>

int main() {
	int i = 12;
	int*pi = &i;
	/* Variable i enthält 12,
	pointer auf i enthält die Adresse von i,
	dereferenzierter pointer enthält den Wert auf den die Adresse zeigt */
	printf("i: %d, &i: %p, p -> %d", i, pi, *pi);
	return 0;
}
```

## 6.1 Pointer als Parameter

* Pointer können als Parameter an Funktionen übergeben werden
* Wird ein Pointer an eine Funktion übergeben, wirkt sich eine Änderung des übergebenen Pointers nicht auf das Original aus. Eine Änderung an der durch den Pointer referenzierten Variable aber schon
* Folgendes Bsp. demonstriert das


__Bsp.: Fakultät (Call-by-Value)__

* Der Wert $x$ wird als Parameter übergeben
* Wir können $x$ in der Funktion verändern
* Die Variable $i$ in `main` wird nicht beeinflusst, $x$ ist eine Kopie von $i$

```run-c
#include <stdio.h>

long fakult(int x) {
	long f = 1;
	while (x > 1) f *= x--;
	return f;
}

int main() {
	int i = 5;
	long f;
	f = fakult(i);
	printf("Fakultaet von %d: %ld\n", i, f);
	return 0;
}
```


__Bsp.: Fakultät (Call-by-Reference)__

* An Stelle des Wertes von $x$ wird die Adresse von $x$ als Pointer übergeben
* Entsprechend wird in der Funktion in Zeile 22 dereferenziert ($*px$)
* In `main` wird $i$ aber dadurch $1$, weil in Zeile 22 der dereferenzierte Wert dekrementiert wird, bis er $1$ ist
* $px$ zeigt auf $i$, $*px$ kann $i$ verändern

```run-c
#include <stdio.h>

long fakult(int *px) {
	long f = 1;
	while ((*px) > 1) { // Dereferenzieren von px (Wert auf Pointer)
		f *= (*px);
		(*px)--; // Wert an der Adresse von px dekrementieren
	}
	return f;
}

int main() {
	int i = 5;
	long f;
	f = fakult(&i); // Adresse von i übergeben
	printf("Fakultaet von %d: %ld\n", i, f); // i ist jetzt 1
	return 0;
}
```


__Bsp.: Swap-Funktion (Call-by-Reference mit Pointern)__

*   Die Funktion swap` bekommt zwei Pointer auf `int`-Werte und vertauscht diese
*   Es werden hier die originalen Werte von $i$ und $j$ in `main` vertauscht

```run-c
#include <stdio.h>

void swap(int *pa, int *pb) {
	*pa^=*pb; *pb^=*pa; *pa^=*pb;
}

int main() {
	int i=12, j=99;
	printf("i:%d j:%d\n",i,j);
	swap(&i,&j);
	printf("i:%d j:%d\n",i,j);
	return 0;
}
```


__Bsp.: Swap-Funktion (Call-by-Value ohne Pointer)__

*   funktioniert nicht
*   Nur die Kopien von $i$ und $j$ unter den Namen $a$ und $b$ werden vertauscht
*   $i$ und $j$ bleiben unberührt

```run-c
#include <stdio.h>

void swap(int a, int b) {
	a^=b; b^=a; a^=b;
}

int main() {
	int i=12, j=99;
	printf("i:%d j:%d\n",i,j);
	swap(i,j); // Hier werden Kopien übergeben
	printf("i:%d j:%d\n",i,j);
	return 0;
}
```

## 6.2 Pointer und Arrays

Wir haben bereits bei der Betrachtung primitiver Datentypen gelernt, dass der Name eines Arrays mit der Adresse des ersten Elements verknüpft ist. Der Name ist hier `array` und bezeichnet die niederwertigste Adresse des Wertes $326$ innerhalb des Arrays

```c
int array[3] = {326, 2147, 12};
```

Diese Adresse des Arrays kann auch einer Pointervariablen zugewiesen werden. Dabei wird kein Adressoperator (`&`) verwendet, weil der Name `array` ja schon die Adresse eines `int`-Wertes verkörpert

```c
int *pi = array;
```

Da `array` lediglich ein konstanter Pointer auf einen `int`-Wert darstellt, können wir statt `array[0]` auch
* `*array`
* `*(array+0)`
verwenden. Alle drei Notationen sind erlaubt und liefern die $326$
* `array++` funktioniert aber nicht, da `array` ein konstanter Pointer ist

Umgekehrt können wir auch statt `array[0]` verwenden
- `*pi`
* `*(pi+0)`
* `pi[0]`
Alle drei Schreibweisen liefern auch den Wert $326$

## 6.3 Pointerarithmetik

* Mit Pointern kann man auch rechnen, aber sie folgen einer eigenen Arithmetik
* Erlaubt sind die Addition und die Subtraktion ganzzahliger Werte zu Pointern
* Dabei werden die zu addierenden oder zu subtrahierenden Werte zunächst mit der Größe in Bytes des assoziierten Datentyps multipliziert, erst dann wird die Addition durchgeführt

* Bezogen auf unser letztes Bsp., in dem es das Array `array` von `int`-Werten gab, bedeutet das:
    * `pi+1` liefert $pi + 1 \cdot \text{sizeof(int)}$
    * Mit $\text{sizeof(int)}=4$, ein `int`-Wert belegt 4 Byte im Speicher, wird die Adresse bei einer Addition von $1$ um den Wert $4$ erhöht, bei `double` mit einer Länge von $8$ Byte, entsprechend $8$
* Pointerarithmetik rechnet immer mit Items des assoziierten Datentyps


__Bsp.: Zugriff auf Array-Elemente via Pointer__

Zugriff auf das Element mit dem Index $1$ wird auf verschiedene Weise demonstriert

```run-c
#include <stdio.h>

int main() {
	int array[3] = {326, 2147, 12};
	int *pi = array;

	printf("array[1]   : %d\n", array[1]);
	printf("*(array+1) : %d\n", *(array+1));
	printf("*(pi+1)    : %d\n", *(pi+1));
	printf("pi[1]      : %d\n", pi[1]);

	return 0;
}
```


__Bsp.: Verschiedene Schreibweisen für Pointer und Arrays__

```run-c
#include <stdio.h>

int main() {
	int array[3] = {326, 2147, 12};
	int *pi = array;
	int i;

	printf("array[i]   : ");
	for (i = 0; i < sizeof(array) / sizeof(int); i++)
		printf("%d, ", array[i]);
	printf("\n");

	printf("pi[i]      : ");
	for (i = 0; i < sizeof(array) / sizeof(int); i++)
		printf("%d, ", pi[i]);
	printf("\n");

	printf("*(array+i) : ");
	for (i = 0; i < sizeof(array) / sizeof(int); i++)
		printf("%d, ", *(array + i));
	printf("\n");

	printf("*(pi+i)    : ");
	for (i = 0; i < sizeof(array) / sizeof(int); i++)
		printf("%d, ", *(pi + i));
	printf("\n");

	printf("*pi++      : ");
	for (i = 0; i < sizeof(array) / sizeof(int); i++)
		printf("%d, ", *pi++); // pi wird inkrementiert
	printf("\n");

	return 0;
}
```

## 6.4 Operationen mit Pointern

- Zuweisung
- Vergleich auf `==` und `!=`
- Addition von int-Werten
- Subtraktion von int-Werten
- Pointer lassen sich nach long konvertieren
- Dereferenzierung `*`
- Adressbildung `&`


## 6.5 Generischer Pointer

- Ein Pointer vom Typ void* wird auch „Generischer Pointer“ bezeichnet
- Er ist zuweisungskompatibel zu jedem Pointer
- Er kann nicht dereferenziert werden
- Mit void-Pointern kann man nicht rechnen


## 6.6 NULL

- NULL ist ein spezieller Pointer, der Nullpointer
- Dahinter verbirgt sich (void*)0L
- Mittels Typecast wird der Longwert 0 in einen ungetypten Pointer (generischer Pointer) umgewandelt.

## 6.7 Doppelpointer

Ein Pointer kann wiederum auf einen Pointer zeigen.

![[Pasted image 20251203144648.png]]

## 6.8 CommandLineArguments

* Eine Konstruktion dieser Form gibt es als Parameter der `main`-Funktion als sog. Commandlinearguments oder dt. Kommandozeilenargumente
* Sie ermöglichen, Werte vom Programmaufruf an ein c-Programm zu übergeben

```c
 int main(int argc, char** argv)
```
* Dabei enthält `argc` die Anzahl der Parameter und `argv` die Argumente als Strings oder nullterminierte Zeichenketten

* Das erste Kommandozeilenargument ist in c immer der Programmaufruf selbst
* Die weiteren Argumente folgen
* `argv` ist ein Pointer auf ein Array von char-Pointern, die auf Strings verweisen
* Die Schreibweise `char* argv[]` ist ebenfalls möglich und auch üblich


__Bsp.: Ausgabe von Kommandozeilenargumenten__

```run-c
#include <stdio.h>

int main(int argc, char** argv) {
	int i;
	for (i = 0; i < argc; i++)
		printf("argv[%d]: %s\n", i, argv[i]);
	return 0;
}
```

Ausgabe (mit Argumenten):
```bash
$ ./a.out hans otto anna henriette
argv[0]: ./a.out
argv[1]: hans
argv[2]: otto
argv[3]: anna
argv[4]: henriette
```


__Bsp.: Überprüfung der Kommandozeilenargumente__

Bei der Verwendung von Kommandozeilenargumenten sollte als erstes in `main` getestet werden, ob die nötigen Argumente beim Programmaufruf angegeben worden sind

```run-c
#include <stdio.h>
#include <stdlib.h> // Für exit()

int main(int argc, char** argv) {
	// Hier werden die Kommandozeilenargumente getestet,
	// bei Bedarf wird eine usage-Meldung ausgegeben.
	if (argc != 3) { // Programm erwartet 2 zusätzliche Argumente (total 3: ./a.out <name1> <name2>)
		printf("usage: %s <name1> <name2>\n", argv[0]);
		exit (-1); // Programm nicht erfolgreich beenden
	}

	// alles ok, zwei Namen wurden angegeben
	printf("%s liebt %s\n", argv[1], argv[2]);

	return 0;
}
```

Ausgabe (falsche Anzahl Argumente):
```bash
$ ./a.out
usage: ./a.out <name1> <name2>
```

Ausgabe (korrekte Anzahl Argumente):
```bash
$ ./a.out hans anna
hans liebt anna
```


## 6.9 Pointer als Returnwert

* Eine Funktion kann einen Pointer zurückgeben
* Zu beachten ist dabei, dass die Variable, auf die der Pointer verweist, noch existiert, wenn die Funktion verlassen wurde
* Eine Funktion darf keinen Pointer auf automatische, lokale Variable zurückgeben
* Pointer auf lokale statische Variablen dürfen zurückgegeben werden, da diese bis zum Ende der Programmausführung existieren