- bei der Verarbeitung der Daten einer Datei spricht man von Datenstrom
- Datenträger $\rightarrow$ Speicher (ins Programm): Eingabestrom
- Speicher (vom Programm) $\rightarrow$ Datenträger: Ausgabestrom
- die high level IO arbeitet mit einem Streampointer FILE*

![[Pasted image 20251217144402.png]]

## 8.1 Öffnen von Dateien

- Dateien liegen auf Datenträgern
- Um mit Dateien zu arbeiten, muss zunächst über das Betriebssystem eine Verbindung zwischen unserem Programm und den Daten auf dem Datenträger hergestellt werden
- Das geschieht, in dem eine Datei geöffnet wird (Bsp.: `fopen`)

### 8.1.1. Dateizugriffsmodi mit `fopen`

- die Funktion `fopen` dient zum Öffnen von Dateien
- Syntax für `fopen`: `FILE *Dateizeiger = fopen("Dateiname.txt", "Modus");`
- der Dateizeiger ist ein Zeiger vom Typ `FILE*` auf die geöffnete Datei
- `"Dateiname.txt"` ist der Dateiname inklusive Dateipfad
- `"Modus"` ist eine Zeichenkette, die den gewünschten Arbeitsmodus angibt

- der Modus besteht aus zwei Zeichen
- das erste Zeichen definiert den Lese-/Schreibmodus
- das zweite Zeichen gibt den Dateityp an (Bsp.: `t` für Text, `b` für Binär)

- bei Textdateien unter Microsoft:
- Zeilenenden bestehen aus den Bytes `0x0d 0x0a`
- diese Bytes werden als `\n` zusammengefasst
- zwei Bytes werden gelesen, aber nur `\n` zurückgegeben
- bei anderen Systemen ist diese Unterscheidung irrelevant


__Überblick über die gängigen Modi__

| Modus | Beschreibung (Textdatei)                                                                       | Modus (Binärdatei) |
| :---- | :--------------------------------------------------------------------------------------------- | :----------------- |
| r     | zum Lesen öffnen                                                                               | rb                 |
| w     | zum Schreiben (überschreibt Inhalt) öffnen, ggf. erzeugt<br>(ab dem ersten Bite, überschreibt) | wb                 |
| a     | zum Schreiben am Dateiende öffnen, ggf. erzeugt<br>(am Ende, schreibt weiter)                  | ab                 |
| r+    | zum Lesen und Schreiben öffnen (ändert bestehende Datei)                                       | r+b                |
| w+    | zum Lesen und Schreiben öffnen (überschreibt Inhalt), ggf. erzeugt                             | w+b                |
| a+    | zum Anfügen, Lesen, Erzeugen öffnen, ggf. erzeugt                                              | a+b                |

## 8.2 Gepuffertes Lesen/Schreiben

>Dateifunktionen arbeiten gepuffert, um höhere Geschwindigkeiten zu erreichen.

__Lesen__
- beim Lesen wird nicht nur die gerade angeforderte Datenmenge, sondern ein größerer Datenblock in einen Zwischenspeicher (Puffer) übertragen
- weitere Leseoperationen beziehen ihre Daten dann aus diesem Puffer
- wenn der Puffer bis zum Ende gelesen wurde, erfolgt das nächste Lesen wieder vom Datenträger

__Schreiben__
- beim Schreiben verhält es sich ähnlich
- zu schreibende Daten werden zunächst in einen Puffer geschrieben
- der Pufferinhalt wird dann in die Datei übertragen,
  wenn der Puffer voll ist
  wenn ein Zeilenumbruch (`\n`) ausgegeben wird
  wenn die Datei geschlossen wird (mittels `fclose`)
- stürzt ein Programm ab, können Daten zwar im Puffer sein, aber noch nicht in die Datei übertragen worden sein

### 8.2.1 Lesen/Schreiben von Bytes

| Funktion                          | Verwendung                                                                                |
| :-------------------------------- | :---------------------------------------------------------------------------------------- |
| `int fgetc(FILE* stream);`        | liest das nächste Zeichen (Byte) als `unsigned char` oder $EOF$ (end of file, Fehlerfall) |
| `int fputc(int c, FILE* stream);` | schreibt das Zeichen `c` oder Byte in den Stream                                          |

- $EOF$ hat den Wert $-1$
- die Funktion `fgetc` liest ein Byte aus dem Datenstrom, das Werte zwischen $0$ und $255$ annehmen kann
- im 8-Bit-Bereich haben der vorzeichenlose Wert $255$ und der Wert $-1$ die gleiche Bitfolge
- deshalb ist der Rückgabewert von `fgetc` vom Typ `int`
- die Unterscheidung zwischen $255$ und $-1$ ist wichtig wegen der größeren Verarbeitungsbreite


### 8.2.2 Lesen/Schreiben von Text

| Funktion                                           | Verwendung                                                                                                                                                                  |
| :------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `char* fgets(char*s, int n, FILE*stream);`         | liest maximal $n-1$ Zeichen, endet bei Zeilenumbruch (wird mit eingelesen), fügt ein terminierendes $0$ an<br>$\rightarrow$ liest eine Zeile und gibt sie als string zurück |
| `char* fputs(const char*s, FILE* stream);`         | schreibt die nullterminierte Zeichenkette $s$ und einen Zeilenumbruch $ \n $ in den Stream                                                                                  |
| `int fprintf(FILE* stream, const char* fmt, ...);` | schreibt formatierte Daten in den Stream (ähnlich `printf`)                                                                                                                 |
| `int fscanf(FILE* stream, const char* fmt, ...);`  | liest formatierte Daten aus dem Stream (ähnlich `scanf`)                                                                                                                    |

### 8.2.3 Lesen/Schreiben von Binärdaten

| Funktion                                                         | Verwendung                                                                                                                                                                                   |
| :--------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `size_t fread(void* ptr, size_t size, size_t n, FILE* stream);`  | liest maximal $n$ Objekte der Größe $size$ aus dem Stream und speichert sie bei Adresse $ptr$. Rückgabewert ist die Anzahl der gelesenen Objekte ($EOF$ oder `ferror` liefern Fehlerzustand) |
| `size_t fwrite(void* ptr, size_t size, size_t n, FILE* stream);` | schreibt maximal $n$ Objekte der Größe $size$ in den Stream. Rückgabewert ist die Anzahl der geschriebenen Objekte                                                                           |

>Beim Lesen von Dateien wird der Wert auf den Pointer zeigen nicht mit eingelesen
### 8.2.4 Positionierung in Datei

| Funktion                                            | Verwendung                                                                                                                                                                |
| :-------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `int fseek(FILE* stream, long offset, int origin);` | Setzt die Dateiposition auf den Wert $offset$, relativ zum Dateianfang ($origin=SEEK\_SET$), Dateiende ($origin=SEEK\_END$) oder zum aktuellen Stand ($origin=SEEK\_CUR$) |
| `long ftell(FILE* stream);`                         | Liefert die aktuelle Lese-/Schreibposition                                                                                                                                |
| `void rewind(FILE* stream);`                        | Stellt die Lese-/Schreibposition auf den Dateianfang                                                                                                                      |

## 8.3 Schließen von Dateien

- ein Programm kann nur eine plattformabhängig endliche Zahl von Dateien gleichzeitig offen haben
- deshalb müssen Dateien, wenn nicht mehr geschrieben/gelesen wird, wieder geschlossen werden (mittels `fclose`)
- dabei werden ggf. Pufferinhalte noch in die Datei übertragen und Speicherbereiche, die sich hinter dem Streampointer vom Typ `FILE*` verbergen, freigegeben
- beim Verlassen eines Programms auf dem PC (Prozess endet) werden offene Dateien automatisch geschlossen

## 8.4 Bsp.: Studentendaten in Datei speichern und lesen

Dieses Bsp. zeigt, wie man mit C-Dateifunktionen strukturierte Daten (hier: Studentendaten) in eine Binärdatei schreiben und wieder lesen kann. Das Bsp. besteht aus drei Dateien:

### 8.4.1 Programmcode

__main1.c__

Die Hauptdatei `main1.c` öffnet eine Datei, schreibt einen Studentendatensatz hinein und liest anschließend alle gespeicherten Studentendatensätze wieder aus, um sie auf der Konsole anzuzeigen.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "student1.h"

char buf[128]; // Dieser lokale Buffer wird hier nicht verwendet, siehe student1.c

int main(int argc, char** argv) {
    FILE* pf = NULL;
    tStud stud;
    tStud* pStud;

    // Die im Programm verwendeten Funktionen displayStudent, getStudent, writeStud und readStud
    // sind in der Headerdatei student1.h deklariert und in student1.c definiert.
    // Der Datentyp tStud ist ebenfalls in student1.h definiert.

    // Überprüfung der Kommandozeilenargumente
    if (argc != 2) {
        printf("usage: %s <file>\\n", argv[0]);
        exit(-1);
    }

    // Datei im Modus "ab" (append binary) öffnen oder erstellen
    // Neue Daten werden ans Ende angehängt
    pf = fopen(argv[1], "ab"); // Zeile 17: Die Datei wird im Modus `ab` geöffnet, um neue Studentendaten an das Ende der Datei anzuhängen
    if (pf == NULL) {
        printf("file: %s could not open/create\\n", argv[1]);
        exit(-1);
    }

    // Studentendaten erfassen und in die Datei schreiben
    pStud = getStudent(); // Zeile 23: Ein neuer Studentendatensatz wird mit `getStudent()` erfasst
    if (pStud) {
        writeStud(pf, pStud); // Zeile 24: Der erfasste Datensatz wird mit `writeStud()` in die Datei geschrieben
    }
    fclose(pf); // Datei schließen

    // Datei im Modus "rb" (read binary) öffnen
    // um die Daten zu lesen
    pf = fopen(argv[1], "rb"); // Zeile 26: Die Datei wird erneut, diesmal im Modus `rb` (read binary), geöffnet
    if (pf == NULL) {
        printf("file: %s could not open/create\\n", argv[1]);
        exit(-1);
    }

    // Alle Studentendaten aus der Datei lesen und anzeigen
    while ((pStud = readStud(pf)) != NULL) { // Zeile 27-28: In einer Schleife werden alle Studentendatensätze mit `readStud()` aus der Datei gelesen und mit `displayStudent()` angezeigt, bis das Dateiende erreicht ist
        displayStudent(pStud);
    }
    fclose(pf); // Datei schließen

    return 0;
}
```


__student1.h__

Die Headerdatei `student1.h` definiert die Struktur `tStud` für Studentendaten und deklariert die Funktionen zur Handhabung dieser Daten.

```c
#ifndef STUDENT1_H
#define STUDENT1_H

extern char buf[]; // `extern char buf[];` deklariert einen globalen Puffer, der in `student1.c` definiert wird und für Eingaben in `getStudent()` verwendet wird

// Struktur zur Speicherung von Studentendaten
typedef struct tStudent { // Die Struktur `tStud` fasst alle relevanten Daten eines Studenten zusammen
    char name[30+1]; // Name des Studenten (max. 30 Zeichen + Nullterminator)
    int matrNr;      // Matrikelnummer
    float noteKl;    // Note Klausur
    int noteBel;     // Note Beleg
} tStud;

// Die Funktionen sind hier nur deklariert; ihre Implementierung befindet sich in `student1.c`.

// Funktion zur Anzeige eines Studentendatensatzes
void displayStudent(tStud *s);

// Funktion zur Erfassung eines Studentendatensatzes von stdin
tStud* getStudent();

// Funktion zum Schreiben eines Studentendatensatzes in eine Datei
int writeStud(FILE* pf, tStud* ps);

// Funktion zum Lesen eines Studentendatensatzes aus einer Datei
tStud* readStud(FILE* pf);

#endif // STUDENT1_H
```


__student1.c__

Die Implementierungsdatei `student1.c` enthält die Definitionen der Funktionen zur Verwaltung der Studentendaten.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "student1.h"

// Definition des globalen Buffers, der in student1.h deklariert wurde
char buf[128]; 

// Die Funktionen displayStudent und getStudent handhaben die Ein- und Ausgabe auf der Konsole
// und werden hier nicht im Detail besprochen.

// Funktion zur Anzeige eines Studentendatensatzes
void displayStudent(tStud *s) {
    printf("%-30s, %6d, %3.1f, %d\\n",
           s->name,
           s->matrNr,
           s->noteKl,
           s->noteBel);
}

// Funktion zur Erfassung eines Studentendatensatzes
tStud* getStudent() {
    static tStud stud; // Statische Variable, die über Funktionsaufrufe hinweg erhalten bleibt
    // Die Funktionen displayStudent und getStudent werden hier nicht näher betrachtet,
    // da sie grundlegende Ein-/Ausgabeoperationen abdecken.

    printf("Name: ");
    fgets(buf, 32, stdin); // Liest Namen inkl. Zeilenumbruch in den globalen Puffer
    buf[strcspn(buf, "\\n")] = 0; // Entfernt den Zeilenumbruch
    strncpy(stud.name, buf, sizeof(stud.name) - 1);
    stud.name[sizeof(stud.name) - 1] = 0; // Sicherstellen der Nullterminierung

    printf("MatrikelNr: ");
    fgets(buf, 32, stdin);
    stud.matrNr = atoi(buf);

    printf("Note Klausur: ");
    fgets(buf, 32, stdin);
    stud.noteKl = atof(buf); // atof für float

    printf("Note Beleg: ");
    fgets(buf, 32, stdin);
    stud.noteBel = atoi(buf);

    return &stud; // Gibt einen Zeiger auf die statische Struktur zurück
}

// Funktion zum Schreiben eines Studentendatensatzes in eine Datei
int writeStud(FILE* pf, tStud* ps) {
    // Schreibt eine 1:1 Kopie der Struktur in die Datei
    return fwrite(ps, sizeof(*ps), 1, pf); // Die Funktion `writeStud` speichert eine 1:1 Kopie des `tStud`-Objekts direkt in die Datei
}

// Funktion zum Lesen eines Studentendatensatzes aus einer Datei
tStud* readStud(FILE* pf) {
    static tStud stud = {}; // Statische Variable für die gelesenen Daten
    tStud *pStud = &stud;
    // Die Funktion `readStud` liest einen Studentendatensatz aus der Datei in eine statische Struktur und gibt einen Zeiger darauf zurück.
    // Bei jedem Aufruf wird der nächste Datensatz gelesen. Wenn keine Daten mehr gelesen werden können (Dateiende oder Fehler),
    // wird `NULL` zurückgegeben. Der Rückgabewert ist ein Zeiger auf eine statische lokale Variable.
    int ret = fread(&stud, sizeof(tStud), 1, pf); // Liest einen Studentendatensatz

    // Wenn keine Daten mehr gelesen werden konnten (Dateiende oder Fehler),
    // wird NULL zurückgegeben.
    if (ret == 0) { // fread gibt 0 zurück bei Dateiende oder Fehler
        pStud = NULL;
    }
    return pStud; // Gibt Zeiger auf die statische Struktur zurück
}
```

### 8.4.2 Anmerkungen

- Die Daten werden direkt (1:1) in die Datei geschrieben. Dies ist nur möglich, wenn die Daten keine Zeiger enthalten.
- Die Speicherung der Daten ist plattformabhängig (wegen Byte-Reihenfolge und Verarbeitungsbreite). Das bedeutet, die Datei kann auf einem anderen System eventuell nicht korrekt gelesen werden.
- Alle Datensätze haben die gleiche Größe. Dadurch kann man mit Funktionen wie `fseek` gezielt auf einzelne Datensätze zugreifen, um sie zu lesen oder zu ändern.
- Die Daten in der Datei sind in Binärform gespeichert und können nicht einfach mit einem Texteditor gelesen oder bearbeitet werden.

```c
fseek(pf, 0, SEEK_END); // Zeiger ans Dateiende setzen  
int n = ftell(pf) / sizeof(tStud); // Anzahl der Datensätze berechnen  
rewind(pf); // Zeiger wieder an den Dateianfang setzen  
```

Bei Binärdateien, die Strukturen als 1:1 Kopie speichern, haben alle Datensätze die gleiche Größe. Dies ist vergleichbar mit einem Array im Arbeitsspeicher. Daher kann man die Gesamtanzahl der Datensätze ermitteln, indem man die Gesamtgröße der Datei durch die Größe eines einzelnen Datensatzes teilt.

### 8.4.3 Arbeitsweise

Nach mehrmaligem Aufruf sind mehrere Datensätze in der Datei gespeichert.
Es ergibt sich folgende Ausgabe:

![[Pasted image 20251217153114.png]]

## 8.5 Textdateien

- Daten werden heute oft in Textdateien gespeichert
- Vorteil: sie sind visuell lesbar und können mit einem gewöhnlichen Editor bearbeitet werden
- jede Information muss als Text vorliegen
- einzelne Informationen werden durch Trennzeichen getrennt
- die Trennung erfolgt zeilenweise oder durch andere Zeichen

### 8.5.1 Einfache Textdateien

| Zeilenweise Trennung der Informationen                                                                                               | Commaseparated Values (CSV)                                                                                                                          |
| :----------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| Jede Information steht in einer eigenen Zeile. Beim Lesen erfolgt die Zuordnung zu Datenstrukturen in der Reihenfolge des Einlesens. | Die Daten eines Datensatzes (Bsp.: Struktur) stehen in einer Zeile, durch Kommas getrennt. Das Trennzeichen (Komma) darf kein Datenbestandteil sein. |
| Hans Huckebein<br>12121<br>2.3<br>2<br>Anner Haberland<br>12321<br>2.0<br>1                                                          | Hans Huckebein,12121,2.3,2<br>Anna Haberland,12321,2.0,1                                                                                             |

### 8.5.2 Zeilenweises Lesen von Textdateien

Das folgende Bsp. zeigt ein einfaches C-Programm zum zeilenweisen Lesen und Ausgeben einer Textdatei.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char buf[128];

int main(int argc, char* argv[])
{
    FILE *pf;
    if (argc != 2)
    {
        printf("usage: %s <file>\\n", argv[0]);
        exit (-1);
    }

    pf=fopen(argv[1],"rt");
    if (pf==NULL)
    {
        printf("file: %s could not open/create\\n", argv[1]);
        exit (-1);
    }

    while(fgets(buf,128,pf))
    {
        buf[strlen(buf)-1]=0;
        puts(buf);
    }

    return 0;
}
```

Das Programm liest zeilenweise eine Textdatei, die als Kommandozeilenargument übergeben wird. Jede Zeile wird in den Puffer `$buf$` gelesen, der Zeilenumbruch entfernt und die Zeile anschließend auf der Konsole ausgegeben.

### 8.5.3 Bsp.: Zeilenweise Speicherung

```c
int writeStud(FILE* pf, tStud* ps) {
    return fprintf(pf, "%s\n%d\n%f\n%d\n",
                   ps->name,
                   ps->matrNr,
                   ps->noteKl,
                   ps->noteBel);
}

tStud* readStud(FILE* pf) {
    static tStud stud = {};
    tStud* pStud = &stud;
    int ret;
    char buf[128]; 
    ret = fscanf(pf, "%[^\n]\n%d\n%f\n%d\n", // bis \n, ansonsten Leerzeichen
    
                 (stud.name),
                 &(stud.matrNr),
                 &(stud.noteKl),
                 &(stud.noteBel));
    if (ret <= 0) pStud = NULL;
    return pStud;
}
```

- Daten werden zeilenweise mit `$fprintf$` gespeichert
- das einlesen erfolgt hier mit `$fscanf$`
- das zeilenweise einlesen mit `$fgets$` und anschließender Konvertierung bei Zahlen ist ebenfalls möglich

Das Headerfile und main werden unverändert übernommen. Es ändert sich lediglich die Implementierung von `writeStud` bzw. `readStud`. Unter Microsoft soll in main das `Openflag b` in `t` geändert werden.

### 8.5.4 Bsp.: CSV

```c
int writeStud(FILE* pf, tStud* ps) {
    return fprintf(pf, "%s,%d,%f,%d\n",
                   ps->name,
                   ps->matrNr,
                   ps->noteKl,
                   ps->noteBel);
}

tStud* readStud(FILE* pf) {
    int ret;
    static tStud stud;
    tStud* pStud = &stud;
    ret = fscanf(pf, "%[^,],%d,%f,%d\n",
                 (stud.name),
                 &(stud.matrNr),
                 &(stud.noteKl),
                 &(stud.noteBel));
    if (ret <= 0) pStud = NULL;
    return pStud;
}
```

- Daten eines Datensatzes werden durch Komma getrennt mit `$fprintf$` gespeichert
- jeder Datensatz bildet eine Zeile
- das einlesen erfolgt hier mit `$fscanf$`
- das zeilenweise einlesen mit `$fgets$` und anschließender Konvertierung bei Zahlen ist ebenfalls möglich
- CSV-Dateien können auch mit Office-Systemen bearbeitet werden

Das Headerfile und main werden unverändert übernommen. Es ändert sich lediglich die Implementierung von `writeStud` bzw. `readStud`. Unter Microsoft soll in main das `Openflag b` in `t` geändert werden.

### 8.5.5 Problem mit `$scanf$`

- Zeichenketten werden bei `"%s"` nur bis zum ersten Leerzeichen übernommen
- kommen in Namen Leerzeichen vor, wird der Rest des Namens nicht gelesen
- Lösung 1: lies die ganze Zeile ein (Bsp.: mit `$fgets$`) und zerlege sie dann mit `$strtok$` oder `$strtok_r$`
- Lösung 2: verwende ein spezielles Format im `$scanf$`, Bsp.: `"%[^\n]"` (liest alles bis zum Zeilenumbruch) oder `"%[^,]"` (liest alles bis zum Komma)

### 8.5.6 Zerlegung mittels `$strtok$`

```c
tStud* readStud(FILE* pf) {
    int ret;
    static tStud stud;
    tStud* pStud = &stud;
    char* p = fgets(buf, 128, pf); // Liest die gesamte Zeile in den Puffer
    if (p) {
        // Zerlegt den Pufferinhalt anhand des Kommas als Trennzeichen
        strncpy(stud.name, strtok(buf, ","), 30); // Name
        stud.name[sizeof(stud.name) - 1] = 0; // Sicherstellen der Nullterminierung
        stud.matrNr = atoi(strtok(NULL, ",")); // Matrikelnummer
        stud.noteKl = atof(strtok(NULL, ",")); // Klausurnote
        stud.noteBel = atoi(strtok(NULL, "")); // Belegnote (letztes Feld)
    } else {
        pStud = NULL;
    }
    return pStud;
}
```

- `$strtok$` dient dazu, einen String in kleinere Teile (Tokens) zu zerlegen
- als ersten Parameter gibst du den zu zerlegenden String an
- als zweiten Parameter gibst du einen String mit den Trennzeichen an (Bsp.: `","` für Komma)
- wenn du `$strtok$` erneut aufrufst, um weitere Tokens aus demselben String zu bekommen, übergibst du `NULL` als ersten Parameter

### 8.5.7 JSON

- JSON ist eine textuelle Darstellung von Daten durch Schlüssel-Wert-Paare
- Datenstrukturen werden durch Klammern (geschweifte `{}` für Objekte, eckige `[]` für Listen) abgebildet

```json
{
  "studenten": [
    {
      "name": "Hans Huckebein",
      "matrNr": 12121,
      "noteKl": 2.3,
      "noteBel": 2
    },
    {
      "name": "Anna Haberland",
      "matrNr": 12321,
      "noteKl": 2.0,
      "noteBel": 1
    }
  ]
}
```

### 8.5.8 XML

- XML ist eine textuelle Darstellung von Daten und deren Struktur, die Tags verwendet (ähnlich wie HTML)
- jedes Datenelement wird von einem öffnenden und einem schließenden Tag eingeschlossen
- schließende Tags sind durch einen `/` gekennzeichnet (Bsp.: `<tag>` öffnet, `</tag>` schließt)

```xml
<?xml version="1.0" ?>
<students>
  <student>
    <name>Hans Huckebein</name>
    <matrNr>12121</matrNr>
    <noteKl>2.3</noteKl>
    <noteBel>2</noteBel>
  </student>
  <student>
    <name>Anna Haberland</name>
    <matrNr>12321</matrNr>
    <noteKl>2.0</noteKl>
    <noteBel>1</noteBel>
  </student>
</students>
```

### 8.5.9 Verfügbaren Speicherplatz prüfen
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

// Deklariert einen globalen Zeichen-Array (Puffer) mit 128 Bytes, um Zeilen aus der Datei zu lesen
char buf[128];       

int main(int argc, char* argv[])
{
    int proz; // für einen Prozentwert
    char *p;  // für die Suche nach einem Zeichen in einem String
    int prozmax=0; // für den maximalen Prozentwert, benutzerdefiniert
    
    // Überprüft, ob  korrekte Anzahl von Befehlszeilenargumenten übergeben wurde
    if (argc!=2){fprintf(stderr, "usage: %s <prozent>\n", argv[0]); exit(1);}
	// Wenn nicht genau zwei Argumente (Programmname + ein Parameter) vorhanden sind, wird eine Fehlermeldung auf `stderr` ausgegeben und das Programm beendet sich mit dem Status $1$
    
    system("df > /tmp/df.txt");
    // Führt den Shell-Befehl `df` (disk free) aus, der den verfügbaren Speicherplatz anzeigt, und leitet dessen Ausgabe in die Datei `/tmp/df.txt` um
    
    prozmax=atoi(argv[1]);
    // Konvertiert das erste Befehlszeilenargument (als String) in einen Integer-Wert und speichert es in `prozmax` (dies ist der Schwellenwert für den Prozentwert)
    
    FILE* f=fopen("/tmp/df.txt", "rt");
    // Öffnet die Datei `/tmp/df.txt` im Lesemodus (`"r"`) als Textdatei (`"t"`) und speichert den Dateizeiger in `f`
    
    if (f!=NULL)
    // Überprüft, ob Öffnen der Datei erfolgreich (Dateizeiger ist nicht `NULL`)
    {
        fgets(buf,128,f);
        // Liest die erste Zeile aus der Datei `f` in den Puffer `buf` (diese Zeile wird hier als "Überschrift" markiert und übersprungen)
        
        while (fgets(buf,128,f))
        // Eine Schleife, die zeilenweise aus der Datei liest, solange `fgets` erfolgreich ist (nicht das Dateiende erreicht oder ein Fehler auftritt)
        {
            p=strchr(buf, '%');
            // Sucht im aktuell gelesenen String `buf` nach dem Zeichen `'%'` und speichert einen Zeiger auf dessen erste Fundstelle in `p`
            
            if (p)
            // Überprüft, ob das Zeichen `'%'` im String gefunden wurde (wenn `p` nicht `NULL` ist)
            {
                p--;
                // Setzt den Zeiger `p` um ein Zeichen zurück, um vor dem '%' zu starten (z.B. von "50%" auf "50")
                
                while(isdigit(*p))p--;
                // Bewegt den Zeiger `p` weiter zurück, solange das aktuelle Zeichen eine Ziffer ist (um den gesamten Zahlenwert zu erfassen). `isdigit(*p)` prüft, ob das Zeichen an der Stelle `*p` eine Ziffer ist.
                
                p++;
                // Setzt den Zeiger `p` wieder um ein Zeichen vor, sodass er auf die erste Ziffer des Prozentwertes zeigt
                
                proz=atoi(p)
                // Konvertiert den String ab der aktuellen Position von `p` in einen Integer-Wert und speichert ihn in `proz`
                
                if (proz>=prozmax)
                // Überprüft, ob der ermittelte Prozentwert `proz` größer oder gleich dem maximalen Schwellenwert `prozmax` ist
                
                {
                    char text[128];
                    // Deklariert einen lokalen Zeichen-Array `text` mit 128 Bytes, um einen Befehl für `zenity` zu speichern
                    
                    char* px=strtok(buf, " \t\n");
                    // `strtok` zerlegt den Puffer `buf` (die aktuelle Zeile) beim ersten Vorkommen eines Leerzeichens, Tabulators oder Zeilenumbruchs. `px` zeigt auf den ersten Token (wahrscheinlich der Gerätename oder Mountpunkt).
                    
                    sprintf(text, "zenity --info --text='Prozent %d%% : %s'",proz, px); // Formatiert einen String für den `zenity` Befehl und speichert ihn in `text`. `zenity` ist ein Tool, das Dialogfenster anzeigt. Hier wird eine Informationsbox erstellt, die den Prozentwert und den zugehörigen Datenträger anzeigt.
                    system(text); // Führt den im `text` String gespeicherten Befehl als Shell-Befehl aus, wodurch das `zenity`-Dialogfenster angezeigt wird
                }
            }
        }
        fclose(f);
        // Schließt die zuvor geöffnete Datei, um Ressourcen freizugeben und sicherzustellen, dass alle gepufferten Daten geschrieben werden
        
        remove("/tmp/df.txt");
        // Löscht die temporäre Datei `/tmp/df.txt` nach Gebrauch, um den Speicherplatz zu bereinigen
        
    } else {
    // Dieser Block wird ausgeführt, wenn das Öffnen der Datei `/tmp/df.txt` (aus der `if (f!=NULL)`-Bedingung) fehlschlägt
        
        fprintf(stderr, "could not open /tmp/df.txt\n");
        // Gibt eine Fehlermeldung auf den Standardfehlerausgabe-Stream (`stderr`) aus, wenn die Datei nicht geöffnet werden konnte
    }
    return 0;
}
```

Der Code macht generell folgendes:
* Er überprüft, ob dem Programm ein Argument (ein Prozentwert) übergeben wurde
* Er führt den Shell-Befehl `df` aus, um Informationen über den verfügbaren Speicherplatz zu erhalten, und speichert die Ausgabe in einer temporären Datei (`/tmp/df.txt`)
* Er liest diese temporäre Datei zeilenweise
*  Für jede gelesene Zeile sucht er nach dem Prozentzeichen
* Wenn ein Prozentzeichen gefunden wird, extrahiert er den davorstehenden Zahlenwert
* Anschließend vergleicht er diesen Wert mit dem übergebenen Schwellenwert (`prozmax`)
* Falls der ermittelte Prozentwert den Schwellenwert erreicht oder überschreitet, wird ein Dialogfenster (mittels `zenity`) angezeigt, das über den hohen Speicherverbrauch des betreffenden Datenträgers informiert
* Nach dem Lesen wird die temporäre Datei geschlossen und gelöscht
* Falls die temporäre Datei nicht geöffnet werden konnte, wird eine Fehlermeldung ausgegeben

## 8.6 Daten serialisieren

- Daten werden für den Datentransport und die Speicherung in einen Bytestrom umgewandelt
- dabei werden die Datenkomponenten in Zeichenketten konvertiert
- man spricht vom Serialisieren und Deserialisieren von Daten

Wenn eine Struktur Zeiger enthält, Bsp.: auf Zeichenketten (wie `char *name;`), kann sie nicht direkt 1:1 in eine Datei geschrieben werden, da nur der Zeigerwert, nicht die eigentliche Zeichenkette, gespeichert würde. In solchen Fällen ist Serialisierung notwendig.

```c
typedef struct tStudent {
    char *name;      // Zeiger auf Name
    int matrNr;      // Matrikelnummer
    float noteKl;    // Note Klausur
    int noteBel;     // Note Beleg
} tStud;
```

- jede Datenkomponente wird dabei in eine Zeichenkette umgewandelt
- jeder Zeichenkette wird ihre Länge (in einem Byte) vorangestellt, danach kommen die eigentlichen Zeichen

![[Pasted image 20251217155535.png]]

- das Deserialisieren von Zeichenketten ist besonders effizient
- zuerst wird die Länge einer nachfolgenden Zeichenkette gelesen
- danach wird der benötigte Speicher genau zugewiesen (plus 1 Byte für die Nullterminierung)
- die Zeichenkette kann dann ohne Zwischenpuffer direkt in ihren Zielspeicher gelesen werden

