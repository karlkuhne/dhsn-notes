## 9.1 Rekursive Funktion

- eine rekursive Funktion ist eine Funktion, die sich selbst aufruft
- man unterscheidet Linksrekursion, Rechtsrekursion und Zentralrekursion
- links- und rechtsrekursive Probleme können auch iterativ gelöst werden, zentralrekursive Probleme nicht

## 9.2 Rekursiver Aufruf

- ein rekursiver Aufruf muss an eine Bedingung geknüpft sein, ansonsten kommt es zur Endlosrekursion
- bei jedem rekursiven Aufruf einer Routine (in C: Funktion) wird eine neue Instanz der lokalen Variablen angelegt

### 9.3 Bsp.: linksbündige Ausgabe einer positiven Zahl

```run-c
#include <stdio.h>
#include <stdlib.h>

void uputd(unsigned long d)
{
    printf("Aufruf uputd mit d = %lu\n", d);
    if (d>=10) uputd(d/10);
    putchar('0' + d%10);
    printf("  Ausgabe Ziffer: %lu (d mod 10)\n", d%10);
}

int main()
{
    unsigned int x = 256;
    uputd(x);
    putchar('\n');
    return 0;
}
```

## 9.4 Fakultät (rekursiv)

```run-c
#include <stdio.h>
#include <stdlib.h>

long facult(long z)
{
    long tmp=0;
    printf("Aufruf facult mit z = %ld\n", z);
    if (z > 1) {
        tmp = facult(z-1)*z;
        printf("  Berechne %ld * %ld (für z = %ld) -> Ergebnis: %ld\n", tmp/z, z, z, tmp);
    }
    else {
        tmp = 1;
        printf("  Basisfall erreicht, z = %ld -> Ergebnis: %ld\n", z, tmp);
    }
    printf("  Rückgabe Wert für z = %ld: %ld\n", z, tmp);
    return tmp;
}

int main()
{
    long x = 5;
    printf("Berechnung der Fakultät von %ld:\n\n", x);
    long result = facult(x);
    printf("\nDas finale Ergebnis der Fakultät von %ld ist: %ld\n", x, result);
    return 0;
}
```
## 9.5 Funktionspointer

- C gestattet, mit Hilfe von `typedef` Funktionstypen und Funktionspointertypen zu vereinbaren
- mit diesen Datentypen können dann Variablen, Vektoren, Struktur-/Unionkomponenten oder Funktionsparameter definiert werden
- natürlich können die entsprechenden Definitionen auch direkt und ohne mit `typedef` vereinbarten Datentyp definiert werden