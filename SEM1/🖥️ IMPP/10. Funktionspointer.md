
>Ein Funktionspointer ist eine Variable, die die Speicheradresse einer Funktion speichern kann. Dadurch können Funktionen indirekt aufgerufen oder als Argumente übergeben werden.

## 10.1 Typendeklaration

- man kann mit`typedef` eigene Typen für Funktionen und für Funktionspointer definieren
- diese Typen können dann für die
  Deklaration von Variablen,
  als Elemente in Arrays,
  als Komponenten in Strukturen oder Unions
  oder als Funktionsparameter
  verwendet werden
- es ist auch möglich, Definitionen direkt vorzunehmen, ohne vorher einen `typedef`-Typ erstellt zu haben

## 10.2 Funktionstyp

>Ein Funktionstyp legt die Signatur einer Funktion fest, also welche Parameter sie erwartet und welchen Wert sie zurückgibt.

`typedef void f (void);
Dieser Typ `f` steht für Funktionen, die keine Parameter haben ($void$) und keinen Wert zurückgeben ($void$)

`typedef int fcmp (void* p1, void* p2);`
Dieser Typ `fcmp` steht für Funktionen, die zwei Pointer ($void*$) als Parameter erhalten und einen Integer-Wert ($int$) zurückgeben

Parameternamen können, müssen aber nicht angegeben werden

__Deklaration:__
`f* pF1;`
`f` ist ein Funktionstyp, `pF1` ist ein Pointer auf eine Funktion dieses Typs

### 10.3 Funktionspointertyp

>Ein Funktionspointertyp definiert einen Typ für einen Pointer, der auf eine bestimmte Funktion zeigt.

`typedef void (*pf) (void);`
Dieser Typ `pf` steht für einen Pointer auf eine Funktion, die keine Parameter hat und keinen Wert zurückgibt

Funktionstypen werden grundsätzlich in Verbindung mit Funktionspointern verwendet, um deren Deklaration zu vereinfachen

**Deklaration:**
`pf pF2;`
`pf` ist ein Funktionspointertyp, `pF2` ist eine Variable dieses Typs

## 10.4 Aufruf

Gibt es eine Funktion, kann deren Adresse einer Funktionspointervariablen zugewiesen werden.

Bsp.:
`void fxyz (void) {...}`
`pF1 = fxyz;`

(Der Adressoperator `&` würde in diesem Fall, genauso wie bei Arrays, ignoriert.)

Die Funktion kann nun über die Funktionspointervariable aufgerufen werden:

`pF1 ();`

* der Funktionsaufruf erfolgt in gleicher Weise wie bei einer gewöhnlichen Funktion
* statt des Funktionsnamens wird der Name der Funktionspointervariablen angegeben
* die Parameter müssen entsprechend typverträglich sein

## 10.5 Beispiel

```run-c
#include <stdlib.h>
#include <stdio.h>

typedef void(*f)(int i);
// f: Name des neuen Typs, der ein Pointer * ist
// int i:  Parameterliste der Funktion, auf die der Pointer zeigen wird (erwartet einen Integer-Parameter)
f pf;

void fprintdec(int i) {
    printf("%d\n",i);
}

void fprinthex(int i) {
    printf("%08x\n",i);
}

int main() {
    int i = 67;
    
    pf = fprintdec;
    pf(i); // Aufruf von fprintdec über den Pointer
    
    pf = fprinthex;
    pf(i); // Aufruf von fprinthex über den Pointer
    
    return 0;
}
```

```run-c
#include <stdlib.h>
#include <stdio.h>

void fprintdec(int i) {
    printf("%d\n",i);
}

void fprinthex(int i) {
    printf("%08x\n",i);
}

void fprintxx(void(*fctp)(int), int i) {  
	fctp(i);  
}

int main() {  
	int i = 67;
	
	fprintxx(fprintdec,i); // fprintdec wird als Parameter übergeben
	fprintxx(fprinthex,i); // fprinthex wird als Parameter übergeben
	
	return 0;
}
```

```run-c
#include <stdlib.h>
#include <stdio.h>

typedef void(*f)(int i);

void fprintdec(int i) {
    printf("%d\n",i);
}

void fprinthex(int i) {
    printf("%08x\n",i);
}

f choice(int i) {
    if (i) return fprinthex;
    else return fprintdec;
}

int main() {
    int i = 67;
    
    choice(0)(i); // Ruft fprintdec auf, da 0 als Parameter übergeben wird
    choice(1)(i); // Ruft fprinthex auf, da 1 (ungleich 0) als Parameter übergeben wird
    
    return 0;
}
```

```run-c
#include <stdlib.h>
#include <stdio.h>

typedef void(*f)(int i);

void fprintdec(int i) {
    printf("%d\n",i);
}

void fprinthex(int i) {
    printf("%08x\n",i);
}

// Deklaration und Initialisierung eines Arrays von Funktionspointern
f arr[] = {fprintdec, fprinthex};

int main() {
    int i = 67;

    arr[0](i); // Ruft fprintdec auf
    arr[1](i); // Ruft fprinthex auf
    
    return 0;
}
```

